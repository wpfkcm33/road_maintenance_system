# 프로젝트 코드 수집 결과

**프로젝트 디렉토리:** .
**수집된 파일 수:** 81
**생성 일시:** 2025. 07. 27. (일) 17:55:50 KST

## 📋 파일 목록

1. **index.tsx** - `frontend/src/index.tsx` (404 chars)
2. **App.tsx** - `frontend/src/App.tsx` (3,362 chars)
3. **main.py** - `backend/app/main.py` (5,474 chars)
4. **docker-compose.yml** - `docker-compose.yml` (787 chars)
5. **package.json** - `frontend/package.json` (1,533 chars)
6. **videoService.ts** - `frontend/src/services/videoService.ts` (1,355 chars)
7. **markerService.ts** - `frontend/src/services/markerService.ts` (1,186 chars)
8. **dashboardService.ts** - `frontend/src/services/dashboardService.ts` (739 chars)
9. **api.ts** - `frontend/src/services/api.ts` (807 chars)
10. **analysisService.ts** - `frontend/src/services/analysisService.ts` (674 chars)
11. **marker_service.py** - `backend/app/services/marker_service.py` (7,814 chars)
12. **ai_service.py** - `backend/app/services/ai_service.py` (6,530 chars)
13. **__init__.py** - `backend/app/services/__init__.py` (210 chars)
14. **video_service.py** - `backend/app/services/video_service.py` (2,275 chars)
15. **debug.py** - `backend/app/api/debug.py` (3,110 chars)
16. **markers.py** - `backend/app/api/markers.py` (10,740 chars)
17. **analysis.py** - `backend/app/api/analysis.py` (10,471 chars)
18. **dashboard.py** - `backend/app/api/dashboard.py` (2,692 chars)
19. **__init__.py** - `backend/app/api/__init__.py` (32 chars)
20. **videos.py** - `backend/app/api/videos.py` (23,145 chars)
21. **code_collector.py** - `code_collector.py` (6,472 chars)
22. **postcss.config.js** - `frontend/postcss.config.js` (82 chars)
23. **tailwind.config.js** - `frontend/tailwind.config.js` (1,356 chars)
24. **setupTests.ts** - `frontend/src/setupTests.ts` (241 chars)
25. **react-app-env.d.ts** - `frontend/src/react-app-env.d.ts` (40 chars)
26. **reportWebVitals.ts** - `frontend/src/reportWebVitals.ts` (388 chars)
27. **App.test.tsx** - `frontend/src/App.test.tsx` (241 chars)
28. **helpers.ts** - `frontend/src/utils/helpers.ts` (3,530 chars)
29. **constants.ts** - `frontend/src/utils/constants.ts` (1,483 chars)
30. **analysis.ts** - `frontend/src/types/analysis.ts` (1,194 chars)
31. **dashboard.ts** - `frontend/src/types/dashboard.ts` (427 chars)
32. **naver-maps.d.ts** - `frontend/src/types/naver-maps.d.ts` (4,882 chars)
33. **video.ts** - `frontend/src/types/video.ts` (468 chars)
34. **marker.ts** - `frontend/src/types/marker.ts` (1,232 chars)
35. **VideoComparisonPlayer.tsx** - `frontend/src/components/video/VideoComparisonPlayer.tsx` (13,640 chars)
36. **AIAnalysisResult.tsx** - `frontend/src/components/video/AIAnalysisResult.tsx` (10,248 chars)
37. **VideoPlayer.tsx** - `frontend/src/components/video/VideoPlayer.tsx` (1,277 chars)
38. **VideoUpload.tsx** - `frontend/src/components/video/VideoUpload.tsx` (2,538 chars)
39. **Dashboard.tsx** - `frontend/src/components/dashboard/Dashboard.tsx` (307 chars)
40. **ActivityList.tsx** - `frontend/src/components/dashboard/ActivityList.tsx` (3,081 chars)
41. **StatCard.tsx** - `frontend/src/components/dashboard/StatCard.tsx` (2,531 chars)
42. **NaverMap.tsx** - `frontend/src/components/map/NaverMap.tsx` (18,440 chars)
43. **MarkerPopup.tsx** - `frontend/src/components/map/MarkerPopup.tsx` (883 chars)
44. **MarkerAddPopup.tsx** - `frontend/src/components/map/MarkerAddPopup.tsx` (16,309 chars)
45. **Modal.tsx** - `frontend/src/components/common/Modal.tsx` (2,214 chars)
46. **Sidebar.tsx** - `frontend/src/components/common/Sidebar.tsx` (2,736 chars)
47. **Header.tsx** - `frontend/src/components/common/Header.tsx` (2,066 chars)
48. **LoadingSpinner.tsx** - `frontend/src/components/common/LoadingSpinner.tsx` (706 chars)
49. **MarkerList.tsx** - `frontend/src/components/markers/MarkerList.tsx` (2,035 chars)
50. **MarkerDetail.tsx** - `frontend/src/components/markers/MarkerDetail.tsx` (10,557 chars)
51. **MarkerForm.tsx** - `frontend/src/components/markers/MarkerForm.tsx` (3,384 chars)
52. **useVideo.ts** - `frontend/src/hooks/useVideo.ts` (1,738 chars)
53. **useMarkers.ts** - `frontend/src/hooks/useMarkers.ts` (2,853 chars)
54. **useAIAnalysis.ts** - `frontend/src/hooks/useAIAnalysis.ts` (2,146 chars)
55. **AnalyticsPage.tsx** - `frontend/src/pages/AnalyticsPage.tsx` (728 chars)
56. **MarkersPage.tsx** - `frontend/src/pages/MarkersPage.tsx` (19,525 chars)
57. **SettingsPage.tsx** - `frontend/src/pages/SettingsPage.tsx` (719 chars)
58. **DashboardPage.tsx** - `frontend/src/pages/DashboardPage.tsx` (15,055 chars)
59. **__init__.py** - `backend/app/__init__.py` (0 chars)
60. **config.py** - `backend/app/core/config.py` (1,274 chars)
61. **__init__.py** - `backend/app/core/__init__.py` (0 chars)
62. **database.py** - `backend/app/core/database.py` (699 chars)
63. **__init__.py** - `backend/app/utils/__init__.py` (0 chars)
64. **video_utils.py** - `backend/app/utils/video_utils.py` (9,642 chars)
65. **file_utils.py** - `backend/app/utils/file_utils.py` (1,453 chars)
66. **model_loader.py** - `backend/app/ai_model/model_loader.py` (2,249 chars)
67. **__init__.py** - `backend/app/ai_model/__init__.py` (1,298 chars)
68. **inference.py** - `backend/app/ai_model/inference.py` (13,846 chars)
69. **analysis.py** - `backend/app/models/analysis.py` (1,690 chars)
70. **video.py** - `backend/app/models/video.py` (1,098 chars)
71. **marker.py** - `backend/app/models/marker.py` (1,738 chars)
72. **__init__.py** - `backend/app/models/__init__.py` (335 chars)
73. **analysis.py** - `backend/app/schemas/analysis.py` (2,121 chars)
74. **video.py** - `backend/app/schemas/video.py` (788 chars)
75. **marker.py** - `backend/app/schemas/marker.py` (2,031 chars)
76. **__init__.py** - `backend/app/schemas/__init__.py` (345 chars)
77. **tsconfig.json** - `frontend/tsconfig.json` (627 chars)
78. **sample_data.sql** - `database/sample_data.sql` (0 chars)
79. **init.sql** - `database/init.sql` (0 chars)
80. **README.md** - `README.md` (865 chars)
81. **README.md** - `frontend/README.md` (2,103 chars)

---

## 📁 파일 상세 내용

### 1. index.tsx

- **경로:** `frontend/src/index.tsx`
- **크기:** 404 characters
- **타입:** .tsx

```tsx
// frontend/src/index.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Performance measuring (optional)
reportWebVitals();
```

---

### 2. App.tsx

- **경로:** `frontend/src/App.tsx`
- **크기:** 3,362 characters
- **타입:** .tsx

```tsx
// frontend/src/App.tsx
import React, { useState } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Toaster } from 'react-hot-toast';

// Components
import Header from './components/common/Header';
import Sidebar from './components/common/Sidebar';

// Pages
import DashboardPage from './pages/DashboardPage';
import MarkersPage from './pages/MarkersPage';
import AnalyticsPage from './pages/AnalyticsPage';
import SettingsPage from './pages/SettingsPage';

// Create a client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
});

const App: React.FC = () => {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen);
  };

  const closeSidebar = () => {
    setSidebarOpen(false);
  };

  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <div className="min-h-screen bg-gray-50">
          {/* Header */}
          <Header onToggleSidebar={toggleSidebar} />
          
          {/* Sidebar */}
          <Sidebar isOpen={sidebarOpen} onClose={closeSidebar} />
          
          {/* Main Content */}
          <main className={`
            pt-16 transition-all duration-300 ease-in-out
            ${sidebarOpen ? 'md:ml-64' : 'ml-0'}
          `}>
            <div className="container mx-auto px-4 py-6">
              <Routes>
                <Route path="/" element={<DashboardPage />} />
                <Route path="/markers" element={<MarkersPage />} />
                <Route path="/analytics" element={<AnalyticsPage />} />
                <Route path="/settings" element={<SettingsPage />} />
                <Route path="*" element={<NotFoundPage />} />
              </Routes>
            </div>
          </main>
          
          {/* Toast Notifications */}
          <Toaster
            position="top-right"
            toastOptions={{
              duration: 4000,
              style: {
                background: '#363636',
                color: '#fff',
              },
              success: {
                duration: 3000,
                iconTheme: {
                  primary: '#4ade80',
                  secondary: '#fff',
                },
              },
              error: {
                duration: 5000,
                iconTheme: {
                  primary: '#ef4444',
                  secondary: '#fff',
                },
              },
            }}
          />
        </div>
      </Router>
    </QueryClientProvider>
  );
};

// 404 페이지 컴포넌트
const NotFoundPage: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center min-h-[60vh] text-center">
      <div className="text-6xl mb-4">🚧</div>
      <h1 className="text-2xl font-bold text-gray-900 mb-2">페이지를 찾을 수 없습니다</h1>
      <p className="text-gray-600 mb-6">
        요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.
      </p>
      <button
        onClick={() => window.history.back()}
        className="bg-primary-500 hover:bg-primary-600 text-white px-6 py-2 rounded-lg transition-colors"
      >
        이전 페이지로 돌아가기
      </button>
    </div>
  );
};

export default App;
```

---

### 3. main.py

- **경로:** `backend/app/main.py`
- **크기:** 5,474 characters
- **타입:** .py

```python
# backend/app/main.py (최종 수정 버전)
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse
import os
import uvicorn
import logging

from .core.config import settings
from .core.database import engine, create_tables
from .api import markers, videos, analysis, dashboard
try:
    from .api import debug
    debug_available = True
except ImportError:
    debug_available = False

# 로깅 설정
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# AI 모델 사전 로드 시도
def try_preload_ai_model():
    """AI 모델 사전 로드 시도 (여러 경로)"""
    ai_status = "not_available"
    
    try:
        # 방법 1: app 패키지 내부에서 로드
        from .ai_model.model_loader import preload_model
        preload_model()
        ai_status = "loaded_from_app"
        logger.info("✅ AI 모델을 app 패키지에서 사전 로드 완료")
    except ImportError:
        try:
            # 방법 2: backend 레벨에서 로드
            import sys
            backend_path = os.path.dirname(os.path.dirname(__file__))
            if backend_path not in sys.path:
                sys.path.insert(0, backend_path)
            
            from ai_model.model_loader import preload_model
            preload_model()
            ai_status = "loaded_from_backend"
            logger.info("✅ AI 모델을 backend 레벨에서 사전 로드 완료")
        except ImportError:
            ai_status = "not_found"
            logger.warning("⚠️  AI 모델 로더를 찾을 수 없습니다. AI 기능이 시뮬레이션 모드로 실행됩니다.")
        except Exception as e:
            ai_status = "load_error"
            logger.error(f"❌ AI 모델 로드 중 오류: {e}")
    except Exception as e:
        ai_status = "load_error"
        logger.error(f"❌ AI 모델 사전 로드 실패: {e}")
    
    return ai_status

# AI 모델 로드 시도
ai_load_status = try_preload_ai_model()

# 테이블 생성
try:
    create_tables()
    logger.info("✅ 데이터베이스 테이블 생성/확인 완료")
except Exception as e:
    logger.error(f"❌ 데이터베이스 테이블 생성 실패: {e}")

# FastAPI 앱 생성
app = FastAPI(
    title=settings.PROJECT_NAME,
    description=settings.DESCRIPTION + f" (AI 상태: {ai_load_status})",
    version=settings.VERSION,
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS 미들웨어 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 업로드된 파일 정적 서빙
if not os.path.exists(settings.UPLOAD_FOLDER):
    os.makedirs(settings.UPLOAD_FOLDER, exist_ok=True)
    os.makedirs(os.path.join(settings.UPLOAD_FOLDER, "videos"), exist_ok=True)
    os.makedirs(os.path.join(settings.UPLOAD_FOLDER, "analysis_results"), exist_ok=True)

app.mount("/uploads", StaticFiles(directory=settings.UPLOAD_FOLDER), name="uploads")

# API 라우터 등록
app.include_router(dashboard.router, prefix="/api/dashboard", tags=["Dashboard"])
app.include_router(markers.router, prefix="/api/markers", tags=["Markers"])
app.include_router(videos.router, prefix="/api/videos", tags=["Videos"])
app.include_router(analysis.router, prefix="/api/analysis", tags=["Analysis"])

# 디버그 라우터 (개발 환경에서만)
if debug_available:
    app.include_router(debug.router, prefix="/api/debug", tags=["Debug"])

# 루트 엔드포인트
@app.get("/")
async def root():
    return {
        "message": "🤖 도로 유지보수 관리 시스템 API",
        "version": settings.VERSION,
        "ai_status": ai_load_status,
        "docs": "/docs",
        "features": [
            "마커 관리",
            "비디오 업로드", 
            "AI 균열 검출",
            "분석 결과 시각화"
        ]
    }

# 헬스체크 엔드포인트
@app.get("/health")
async def health_check():
    # AI 모델 상태 확인
    model_status = "unknown"
    try:
        # 방법 1: app 내부
        from .ai_model.model_loader import get_model_loader
        model_info = get_model_loader().get_model_info()
        model_status = "ready" if model_info.get("loaded") else "not_loaded"
    except ImportError:
        try:
            # 방법 2: backend 레벨
            import sys
            backend_path = os.path.dirname(os.path.dirname(__file__))
            if backend_path not in sys.path:
                sys.path.insert(0, backend_path)
            from ai_model.model_loader import get_model_loader
            model_info = get_model_loader().get_model_info()
            model_status = "ready" if model_info.get("loaded") else "not_loaded"
        except:
            model_status = "not_available"
    except:
        model_status = "error"
    
    return {
        "status": "healthy",
        "timestamp": "2024-01-01T00:00:00Z",
        "ai_model": model_status,
        "ai_load_status": ai_load_status,
        "database": "connected",
        "upload_folder": os.path.exists(settings.UPLOAD_FOLDER)
    }

# 전역 예외 핸들러
@app.exception_handler(404)
async def not_found_handler(request, exc):
    return JSONResponse(
        status_code=404,
        content={"message": "요청된 리소스를 찾을 수 없습니다."}
    )

@app.exception_handler(500)
async def internal_error_handler(request, exc):
    logger.error(f"내부 서버 오류: {exc}")
    return JSONResponse(
        status_code=500,
        content={"message": "내부 서버 오류가 발생했습니다."}
    )

# 애플리케이션 시작 이벤트
@app.on_event("startup")
async def startup_event():
    logger.info("🚀 도로 유지보수 관리 시스템 시작")
    logger.info(f"📍 API 문서: http://localhost:8000/docs")
    logger.info(f"🤖 AI 상태: {ai_load_status}")
    logger.info(f"📁 업로드 폴더: {settings.UPLOAD_FOLDER}")

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )
```

---

### 4. docker-compose.yml

- **경로:** `docker-compose.yml`
- **크기:** 787 characters
- **타입:** .yml

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: road_maintenance
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    depends_on:
      - postgres
    environment:
      DATABASE_URL: postgresql://admin:password@postgres:5432/road_maintenance
    volumes:
      - ./backend/uploads:/app/uploads
      - ./backend/ai_model:/app/ai_model

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend
    volumes:
      - ./frontend/src:/app/src

volumes:
  postgres_data:

```

---

### 5. package.json

- **경로:** `frontend/package.json`
- **크기:** 1,533 characters
- **타입:** .json

```json
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@headlessui/react": "^2.2.4",
    "@heroicons/react": "^2.2.0",
    "@tanstack/react-query": "^5.83.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^18.19.120",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "axios": "^1.10.0",
    "chart.js": "^4.5.0",
    "date-fns": "^2.30.0",
    "react": "^19.1.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^19.1.0",
    "react-dropzone": "^14.3.8",
    "react-hot-toast": "^2.5.2",
    "react-router-dom": "^6.30.1",
    "react-scripts": "5.0.1",
    "recharts": "^2.15.4",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4",
    "zustand": "^5.0.6"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@types/react-router-dom": "^5.3.3",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17"
  }
}

```

---

### 6. videoService.ts

- **경로:** `frontend/src/services/videoService.ts`
- **크기:** 1,355 characters
- **타입:** .ts

```typescript
// frontend/src/services/videoService.ts
import api from './api';
import { Video, VideoUpload } from '../types/video';

export const videoService = {
  // 마커별 비디오 목록 조회
  async getMarkerVideos(markerId: number): Promise<Video[]> {
    const response = await api.get(`/api/videos/marker/${markerId}`);
    return response.data;
  },

  // 특정 비디오 조회
  async getVideo(id: number): Promise<Video> {
    const response = await api.get(`/api/videos/${id}`);
    return response.data;
  },

  // 비디오 업로드
  async uploadVideo(markerId: number, upload: VideoUpload): Promise<Video> {
    const formData = new FormData();
    formData.append('file', upload.file);
    formData.append('uploaded_by', upload.uploaded_by);
    if (upload.description) {
      formData.append('description', upload.description);
    }

    const response = await api.post(`/api/videos/upload/${markerId}`, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          console.log(`Upload progress: ${progress}%`);
        }
      }
    });
    return response.data;
  },

  // 비디오 삭제
  async deleteVideo(id: number): Promise<void> {
    await api.delete(`/api/videos/${id}`);
  }
};

```

---

### 7. markerService.ts

- **경로:** `frontend/src/services/markerService.ts`
- **크기:** 1,186 characters
- **타입:** .ts

```typescript
// frontend/src/services/markerService.ts
import api from './api';
import { Marker, MarkerCreate, MarkerUpdate, MarkerStatus, MarkerPriority, IssueType } from '../types/marker';

export interface MarkerQueryParams {
  skip?: number;
  limit?: number;
  status?: MarkerStatus;
  priority?: MarkerPriority;
  issue_type?: IssueType;
  search?: string;
}

export const markerService = {
  // 마커 목록 조회
  async getMarkers(params: MarkerQueryParams = {}): Promise<Marker[]> {
    const response = await api.get('/api/markers/', { params });
    return response.data;
  },

  // 특정 마커 조회
  async getMarker(id: number): Promise<Marker> {
    const response = await api.get(`/api/markers/${id}`);
    return response.data;
  },

  // 마커 생성
  async createMarker(marker: MarkerCreate): Promise<Marker> {
    const response = await api.post('/api/markers/', marker);
    return response.data;
  },

  // 마커 수정
  async updateMarker(id: number, updates: MarkerUpdate): Promise<Marker> {
    const response = await api.patch(`/api/markers/${id}`, updates);
    return response.data;
  },

  // 마커 삭제
  async deleteMarker(id: number): Promise<void> {
    await api.delete(`/api/markers/${id}`);
  }
};

```

---

### 8. dashboardService.ts

- **경로:** `frontend/src/services/dashboardService.ts`
- **크기:** 739 characters
- **타입:** .ts

```typescript
// frontend/src/services/dashboardService.ts
import api from './api';
import { DashboardStats, Activity, RegionStat } from '../types/dashboard';

export const dashboardService = {
  // 대시보드 통계 조회
  async getStats(): Promise<DashboardStats> {
    const response = await api.get('/api/dashboard/stats');
    return response.data;
  },

  // 최근 활동 조회
  async getRecentActivities(limit: number = 10): Promise<Activity[]> {
    const response = await api.get('/api/dashboard/recent-activities', {
      params: { limit }
    });
    return response.data.activities;
  },

  // 지역별 통계 조회
  async getRegionStats(): Promise<RegionStat[]> {
    const response = await api.get('/api/dashboard/region-stats');
    return response.data.regions;
  }
};
```

---

### 9. api.ts

- **경로:** `frontend/src/services/api.ts`
- **크기:** 807 characters
- **타입:** .ts

```typescript
// frontend/src/services/api.ts
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

export const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 요청 인터셉터
api.interceptors.request.use(
  (config) => {
    console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 응답 인터셉터
api.interceptors.response.use(
  (response) => {
    console.log(`API Response: ${response.status} ${response.config.url}`);
    return response;
  },
  (error) => {
    console.error('API Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

export default api;
```

---

### 10. analysisService.ts

- **경로:** `frontend/src/services/analysisService.ts`
- **크기:** 674 characters
- **타입:** .ts

```typescript

// frontend/src/services/analysisService.ts
import api from './api';
import { Analysis } from '../types/analysis';

export const analysisService = {
  // 비디오별 분석 결과 조회
  async getVideoAnalyses(videoId: number): Promise<Analysis[]> {
    const response = await api.get(`/api/analysis/video/${videoId}`);
    return response.data;
  },

  // 특정 분석 결과 조회
  async getAnalysis(id: number): Promise<Analysis> {
    const response = await api.get(`/api/analysis/${id}`);
    return response.data;
  },

  // AI 분석 시작
  async startAnalysis(videoId: number): Promise<Analysis> {
    const response = await api.post(`/api/analysis/start/${videoId}`);
    return response.data;
  }
};
```

---

### 11. marker_service.py

- **경로:** `backend/app/services/marker_service.py`
- **크기:** 7,814 characters
- **타입:** .py

```python
# backend/app/services/marker_service.py
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta

from ..models.marker import Marker, MarkerStatus, MarkerPriority, IssueType
from ..models.video import Video
from ..models.analysis import Analysis
from ..schemas.marker import MarkerCreate, MarkerUpdate


class MarkerService:
    """마커 관련 비즈니스 로직을 처리하는 서비스 클래스"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_marker_with_stats(self, marker_id: int) -> Optional[Dict[str, Any]]:
        """통계 정보가 포함된 마커 조회"""
        
        marker = self.db.query(Marker).filter(Marker.id == marker_id).first()
        if not marker:
            return None
        
        # 비디오 통계
        video_stats = self.db.query(
            func.count(Video.id).label('total_videos'),
            func.sum(Video.file_size).label('total_size'),
            func.avg(Video.duration).label('avg_duration')
        ).filter(Video.marker_id == marker_id).first()
        
        # 분석 통계
        analysis_stats = self.db.query(
            func.count(Analysis.id).label('total_analyses'),
            func.avg(Analysis.confidence_score).label('avg_confidence'),
            func.sum(Analysis.total_cracks_detected).label('total_cracks')
        ).filter(Analysis.marker_id == marker_id).first()
        
        return {
            "marker": marker,
            "video_stats": {
                "count": video_stats.total_videos or 0,
                "total_size_mb": round((video_stats.total_size or 0) / (1024 * 1024), 2),
                "avg_duration_seconds": round(video_stats.avg_duration or 0, 1)
            },
            "analysis_stats": {
                "count": analysis_stats.total_analyses or 0,
                "avg_confidence": round((analysis_stats.avg_confidence or 0) * 100, 1),
                "total_cracks": analysis_stats.total_cracks or 0
            }
        }
    
    def get_markers_by_status_priority(
        self, 
        status: Optional[MarkerStatus] = None,
        priority: Optional[MarkerPriority] = None,
        limit: int = 10
    ) -> List[Marker]:
        """상태와 우선순위로 마커 조회"""
        
        query = self.db.query(Marker)
        
        if status:
            query = query.filter(Marker.status == status)
        
        if priority:
            query = query.filter(Marker.priority == priority)
        
        return query.order_by(Marker.created_at.desc()).limit(limit).all()
    
    def get_urgent_markers(self, days: int = 7) -> List[Marker]:
        """지정된 기간 내 긴급 마커 조회"""
        
        cutoff_date = datetime.now() - timedelta(days=days)
        
        return self.db.query(Marker).filter(
            and_(
                Marker.priority == MarkerPriority.URGENT,
                Marker.status != MarkerStatus.COMPLETED,
                Marker.created_at >= cutoff_date
            )
        ).order_by(Marker.created_at.desc()).all()
    
    def get_completion_rate(self, days: int = 30) -> Dict[str, Any]:
        """완료율 통계"""
        
        cutoff_date = datetime.now() - timedelta(days=days)
        
        total_markers = self.db.query(Marker).filter(
            Marker.created_at >= cutoff_date
        ).count()
        
        completed_markers = self.db.query(Marker).filter(
            and_(
                Marker.created_at >= cutoff_date,
                Marker.status == MarkerStatus.COMPLETED
            )
        ).count()
        
        completion_rate = (completed_markers / total_markers * 100) if total_markers > 0 else 0
        
        return {
            "period_days": days,
            "total_markers": total_markers,
            "completed_markers": completed_markers,
            "completion_rate": round(completion_rate, 2)
        }
    
    def assign_marker_automatically(self, marker_id: int) -> Optional[str]:
        """마커 자동 배정 로직 (예시)"""
        
        marker = self.db.query(Marker).filter(Marker.id == marker_id).first()
        if not marker:
            return None
        
        # 간단한 자동 배정 로직 (실제로는 더 복잡한 로직 구현)
        if marker.priority == MarkerPriority.URGENT:
            assigned_to = "긴급대응팀"
        elif marker.issue_type == IssueType.POTHOLE:
            assigned_to = "도로보수팀"
        elif marker.issue_type == IssueType.SIGN_DAMAGE:
            assigned_to = "표지판관리팀"
        else:
            assigned_to = "일반관리팀"
        
        marker.assigned_to = assigned_to
        marker.updated_at = datetime.now()
        
        try:
            self.db.commit()
            return assigned_to
        except Exception:
            self.db.rollback()
            return None
    
    def get_markers_needing_attention(self) -> List[Marker]:
        """주의가 필요한 마커들 조회"""
        
        # 긴급 마커 중 3일 이상 처리되지 않은 것들
        three_days_ago = datetime.now() - timedelta(days=3)
        
        urgent_old = self.db.query(Marker).filter(
            and_(
                Marker.priority == MarkerPriority.URGENT,
                Marker.status == MarkerStatus.PENDING,
                Marker.created_at <= three_days_ago
            )
        ).all()
        
        # 담당자가 배정되지 않은 마커들
        unassigned = self.db.query(Marker).filter(
            and_(
                Marker.assigned_to.is_(None),
                Marker.status != MarkerStatus.COMPLETED
            )
        ).limit(10).all()
        
        return urgent_old + unassigned


# backend/app/services/video_service.py
from sqlalchemy.orm import Session
from typing import List, Optional, Dict, Any
import os

from ..models.video import Video
from ..models.marker import Marker
from ..core.config import settings


class VideoService:
    """비디오 관련 비즈니스 로직을 처리하는 서비스 클래스"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_storage_usage(self) -> Dict[str, Any]:
        """저장소 사용량 조회"""
        
        total_size = self.db.query(func.sum(Video.file_size)).scalar() or 0
        total_videos = self.db.query(Video).count()
        
        # 평균 파일 크기
        avg_size = total_size / total_videos if total_videos > 0 else 0
        
        return {
            "total_videos": total_videos,
            "total_size_bytes": total_size,
            "total_size_mb": round(total_size / (1024 * 1024), 2),
            "total_size_gb": round(total_size / (1024 * 1024 * 1024), 2),
            "average_size_mb": round(avg_size / (1024 * 1024), 2)
        }
    
    def cleanup_orphaned_videos(self) -> int:
        """마커가 삭제된 고아 비디오들 정리"""
        
        orphaned_videos = self.db.query(Video).filter(
            ~Video.marker_id.in_(
                self.db.query(Marker.id)
            )
        ).all()
        
        deleted_count = 0
        for video in orphaned_videos:
            try:
                # 파일 시스템에서 파일 삭제
                if os.path.exists(video.file_path):
                    os.remove(video.file_path)
                
                # 데이터베이스에서 삭제
                self.db.delete(video)
                deleted_count += 1
                
            except Exception as e:
                print(f"고아 비디오 삭제 실패: {video.id} - {e}")
        
        try:
            self.db.commit()
        except Exception:
            self.db.rollback()
            deleted_count = 0
        
        return deleted_count
    
    def get_videos_without_analysis(self, limit: int = 10) -> List[Video]:
        """분석되지 않은 비디오들 조회"""
        
        return self.db.query(Video).filter(
            ~Video.id.in_(
                self.db.query(Analysis.video_id).filter(
                    Analysis.status.in_([AnalysisStatus.COMPLETED, AnalysisStatus.PROCESSING])
                )
            )
        ).order_by(Video.created_at.desc()).limit(limit).all()
```

---

### 12. ai_service.py

- **경로:** `backend/app/services/ai_service.py`
- **크기:** 6,530 characters
- **타입:** .py

```python
# backend/app/services/ai_service.py (수정된 버전)
import asyncio
import os
import sys
from sqlalchemy.orm import Session
from datetime import datetime
from typing import Dict, List, Any
import uuid
from pathlib import Path

# AI 모듈 import 경로 수정
try:
    # app 내부로 이동한 경우
    from ..ai_model.inference import CrackDetector
    from ..ai_model.model_loader import get_model_loader
except ImportError:
    try:
        # 상위 디렉토리에 있는 경우 (절대 import)
        sys.path.append(os.path.join(os.path.dirname(__file__), '../../'))
        from ai_model.inference import CrackDetector
        from ai_model.model_loader import get_model_loader
    except ImportError as e:
        print(f"AI 모듈 import 실패: {e}")
        # 더미 클래스로 대체 (AI 기능 없이 실행)
        class CrackDetector:
            def analyze_video(self, *args, **kwargs):
                raise Exception("AI 모델이 설치되지 않았습니다.")
        
        def get_model_loader():
            class DummyLoader:
                def get_model_info(self):
                    return {"loaded": False, "error": "AI 모델 없음"}
            return DummyLoader()

from ..core.database import SessionLocal
from ..models.analysis import Analysis, AnalysisStatus
from ..core.config import settings
import logging

logger = logging.getLogger(__name__)

async def start_video_analysis(analysis_id: int, video_path: str):
    """비디오 AI 분석을 백그라운드에서 실행"""
    
    db = SessionLocal()
    try:
        # 분석 상태를 처리 중으로 변경
        analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
        if not analysis:
            logger.error(f"분석 ID {analysis_id}를 찾을 수 없습니다.")
            return
        
        analysis.status = AnalysisStatus.PROCESSING
        analysis.started_at = datetime.now()
        analysis.progress = 5
        db.commit()
        
        logger.info(f"AI 분석 시작: {analysis_id}")
        
        # 출력 비디오 경로 생성
        result_dir = os.path.join(settings.UPLOAD_FOLDER, "analysis_results")
        os.makedirs(result_dir, exist_ok=True)
        
        # 고유한 파일명 생성
        video_filename = f"analysis_{analysis_id}_{uuid.uuid4().hex[:8]}.mp4"
        output_video_path = os.path.join(result_dir, video_filename)
        
        logger.info(f"📁 분석 결과 저장 경로: {output_video_path}")
        
        # 원본 비디오 파일 존재 확인
        if not os.path.exists(video_path):
            raise Exception(f"원본 비디오 파일을 찾을 수 없습니다: {video_path}")
        
        logger.info(f"📹 원본 비디오 확인됨: {video_path} ({os.path.getsize(video_path)} bytes)")
        
        # 진행률 업데이트 콜백
        def progress_callback(progress: float):
            try:
                # 10-90% 범위로 매핑 (전후 처리용 여유 공간)
                mapped_progress = 10 + (progress * 0.8)
                analysis.progress = min(mapped_progress, 90)
                db.commit()
                logger.debug(f"분석 진행률: {mapped_progress:.1f}%")
            except Exception as e:
                logger.warning(f"진행률 업데이트 실패: {e}")
        
        # 실제 AI 분석 실행
        try:
            detector = CrackDetector()
            result = await asyncio.get_event_loop().run_in_executor(
                None, 
                detector.analyze_video,
                video_path,
                output_video_path,
                progress_callback
            )
        except Exception as ai_error:
            logger.error(f"AI 분석 엔진 오류: {ai_error}")
            # AI 분석 실패 시 시뮬레이션으로 대체
            result = await simulate_ai_analysis(analysis_id, video_path, db)
        
        if result["success"]:
            # 분석 완료
            analysis.status = AnalysisStatus.COMPLETED
            analysis.progress = 100
            analysis.total_cracks_detected = result["total_cracks"]
            analysis.total_crack_area = result["total_area"]
            analysis.confidence_score = result["confidence"]
            analysis.crack_details = result["crack_details"]
            analysis.material_estimation = result["material_estimation"]
            analysis.severity_analysis = result["severity_analysis"]
            analysis.result_video_path = output_video_path
            analysis.completed_at = datetime.now()
            
            logger.info(f"AI 분석 완료: {analysis_id} - {result['total_cracks']}개 균열 검출")
        else:
            # 분석 실패
            analysis.status = AnalysisStatus.FAILED
            analysis.error_message = result.get("error", "알 수 없는 오류")
            logger.error(f"AI 분석 실패: {analysis_id}")
        
        db.commit()
        
    except Exception as e:
        logger.error(f"분석 중 예외 발생: {analysis_id} - {str(e)}")
        # 예외 발생 시 실패 상태로 변경
        try:
            analysis.status = AnalysisStatus.FAILED
            analysis.error_message = f"분석 중 오류 발생: {str(e)}"
            analysis.progress = 0
            db.commit()
        except:
            pass
    
    finally:
        db.close()


async def simulate_ai_analysis(analysis_id: int, video_path: str, db: Session) -> Dict[str, Any]:
    """AI 분석 시뮬레이션 (개발/테스트용)"""
    
    try:
        # 진행률 업데이트 시뮬레이션
        for progress in [20, 40, 60, 80, 95]:
            await asyncio.sleep(1)  # 1초 대기
            analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
            if analysis:
                analysis.progress = progress
                db.commit()
        
        # 샘플 분석 결과 생성
        crack_details = [
            {
                "crack_id": "001",
                "crack_type": "횡방향 균열",
                "length": 2.3,
                "width": 15,
                "area": 0.345,
                "severity": "위험",
                "confidence": 0.92
            }
        ]
        
        material_estimation = {
            "asphalt_concrete": 2.1,  # 톤
            "sealer": 45,             # 리터
            "primer": 12,             # 리터
            "mesh": None,
            "total_cost": 1240000     # 원
        }
        
        severity_analysis = {
            "overall_severity": "위험",
            "risk_score": 78.5,
            "urgent_repairs_needed": True,
            "estimated_repair_time": "2-3일"
        }
        
        return {
            "success": True,
            "total_cracks": len(crack_details),
            "total_area": sum(crack["area"] for crack in crack_details),
            "confidence": 0.90,
            "crack_details": crack_details,
            "material_estimation": material_estimation,
            "severity_analysis": severity_analysis
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }
```

---

### 13. __init__.py

- **경로:** `backend/app/services/__init__.py`
- **크기:** 210 characters
- **타입:** .py

```python
from .ai_service import start_video_analysis
from .marker_service import MarkerService
from .video_service import VideoService

__all__ = [
    "start_video_analysis",
    "MarkerService",
    "VideoService"
]

```

---

### 14. video_service.py

- **경로:** `backend/app/services/video_service.py`
- **크기:** 2,275 characters
- **타입:** .py

```python
# backend/app/services/video_service.py
from sqlalchemy.orm import Session
from sqlalchemy import func
from typing import List, Optional, Dict, Any
import os

from ..models.video import Video
from ..models.marker import Marker
from ..core.config import settings


class VideoService:
    """비디오 관련 비즈니스 로직을 처리하는 서비스 클래스"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_storage_usage(self) -> Dict[str, Any]:
        """저장소 사용량 조회"""
        
        total_size = self.db.query(func.sum(Video.file_size)).scalar() or 0
        total_videos = self.db.query(Video).count()
        
        # 평균 파일 크기
        avg_size = total_size / total_videos if total_videos > 0 else 0
        
        return {
            "total_videos": total_videos,
            "total_size_bytes": total_size,
            "total_size_mb": round(total_size / (1024 * 1024), 2),
            "total_size_gb": round(total_size / (1024 * 1024 * 1024), 2),
            "average_size_mb": round(avg_size / (1024 * 1024), 2)
        }
    
    def cleanup_orphaned_videos(self) -> int:
        """마커가 삭제된 고아 비디오들 정리"""
        
        orphaned_videos = self.db.query(Video).filter(
            ~Video.marker_id.in_(
                self.db.query(Marker.id)
            )
        ).all()
        
        deleted_count = 0
        for video in orphaned_videos:
            try:
                # 파일 시스템에서 파일 삭제
                if os.path.exists(video.file_path):
                    os.remove(video.file_path)
                
                # 데이터베이스에서 삭제
                self.db.delete(video)
                deleted_count += 1
                
            except Exception as e:
                print(f"고아 비디오 삭제 실패: {video.id} - {e}")
        
        try:
            self.db.commit()
        except Exception:
            self.db.rollback()
            deleted_count = 0
        
        return deleted_count
    
    def get_videos_without_analysis(self, limit: int = 10) -> List[Video]:
        """분석되지 않은 비디오들 조회"""
        from ..models.analysis import Analysis
        
        return self.db.query(Video).filter(
            ~Video.id.in_(
                self.db.query(Analysis.video_id)
            )
        ).order_by(Video.created_at.desc()).limit(limit).all()
```

---

### 15. debug.py

- **경로:** `backend/app/api/debug.py`
- **크기:** 3,110 characters
- **타입:** .py

```python
# backend/app/api/debug.py (새 파일)
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
import os
import logging

from ..core.database import get_db
from ..core.config import settings
from ..models.video import Video
from ..models.analysis import Analysis

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get("/videos")
async def debug_videos(db: Session = Depends(get_db)):
    """비디오 디버깅 정보"""
    
    videos = db.query(Video).all()
    
    result = []
    for video in videos:
        file_exists = os.path.exists(video.file_path) if video.file_path else False
        file_size_actual = os.path.getsize(video.file_path) if file_exists else 0
        
        result.append({
            "id": video.id,
            "filename": video.filename,
            "original_filename": video.original_filename,
            "file_path": video.file_path,
            "file_exists": file_exists,
            "file_size_db": video.file_size,
            "file_size_actual": file_size_actual,
            "marker_id": video.marker_id,
            "created_at": video.created_at.isoformat(),
            "stream_url": f"/api/videos/{video.id}/stream"
        })
    
    return {
        "total_videos": len(videos),
        "upload_folder": settings.UPLOAD_FOLDER,
        "upload_folder_exists": os.path.exists(settings.UPLOAD_FOLDER),
        "videos": result
    }

@router.get("/analyses")
async def debug_analyses(db: Session = Depends(get_db)):
    """분석 결과 디버깅 정보"""
    
    analyses = db.query(Analysis).all()
    
    result = []
    for analysis in analyses:
        result_file_exists = False
        if analysis.result_video_path:
            result_file_exists = os.path.exists(analysis.result_video_path)
        
        result.append({
            "id": analysis.id,
            "video_id": analysis.video_id,
            "marker_id": analysis.marker_id,
            "status": analysis.status,
            "progress": analysis.progress,
            "result_video_path": analysis.result_video_path,
            "result_file_exists": result_file_exists,
            "total_cracks": analysis.total_cracks_detected,
            "created_at": analysis.created_at.isoformat(),
            "completed_at": analysis.completed_at.isoformat() if analysis.completed_at else None
        })
    
    return {
        "total_analyses": len(analyses),
        "analyses": result
    }

@router.get("/system")
async def debug_system():
    """시스템 디버깅 정보"""
    
    return {
        "upload_folder": settings.UPLOAD_FOLDER,
        "upload_folder_exists": os.path.exists(settings.UPLOAD_FOLDER),
        "videos_folder": os.path.join(settings.UPLOAD_FOLDER, "videos"),
        "videos_folder_exists": os.path.exists(os.path.join(settings.UPLOAD_FOLDER, "videos")),
        "analysis_results_folder": os.path.join(settings.UPLOAD_FOLDER, "analysis_results"),
        "analysis_results_folder_exists": os.path.exists(os.path.join(settings.UPLOAD_FOLDER, "analysis_results")),
        "max_upload_size": settings.MAX_UPLOAD_SIZE,
        "cors_origins": settings.CORS_ORIGINS
    }
```

---

### 16. markers.py

- **경로:** `backend/app/api/markers.py`
- **크기:** 10,740 characters
- **타입:** .py

```python
# backend/app/api/markers.py (완전한 CRUD 포함)
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func
from typing import List, Optional
from datetime import datetime

from ..core.database import get_db
from ..models.marker import Marker, MarkerStatus, MarkerPriority, IssueType
from ..models.video import Video
from ..models.analysis import Analysis
from ..schemas.marker import MarkerCreate, MarkerUpdate, MarkerResponse

router = APIRouter()


@router.get("/", response_model=List[MarkerResponse])
async def get_markers(
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=100),
    status: Optional[MarkerStatus] = None,
    priority: Optional[MarkerPriority] = None,
    issue_type: Optional[IssueType] = None,
    search: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """마커 목록 조회 (필터링 및 검색 지원)"""
    
    query = db.query(Marker)
    
    # 필터 적용
    if status:
        query = query.filter(Marker.status == status)
    if priority:
        query = query.filter(Marker.priority == priority)
    if issue_type:
        query = query.filter(Marker.issue_type == issue_type)
    if search:
        query = query.filter(
            or_(
                Marker.title.ilike(f"%{search}%"),
                Marker.road_name.ilike(f"%{search}%"),
                Marker.address.ilike(f"%{search}%"),
                Marker.assigned_to.ilike(f"%{search}%")
            )
        )
    
    # 정렬 및 페이징
    markers = query.order_by(Marker.created_at.desc()).offset(skip).limit(limit).all()
    
    # 마커별 비디오 및 분석 수 계산
    result = []
    for marker in markers:
        marker_data = MarkerResponse.from_orm(marker)
        marker_data.video_count = len(marker.videos)
        marker_data.analysis_count = len(marker.analyses)
        result.append(marker_data)
    
    return result


@router.get("/{marker_id}", response_model=MarkerResponse)
async def get_marker(marker_id: int, db: Session = Depends(get_db)):
    """특정 마커 상세 조회"""
    
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    marker_data = MarkerResponse.from_orm(marker)
    marker_data.video_count = len(marker.videos)
    marker_data.analysis_count = len(marker.analyses)
    
    return marker_data


@router.post("/", response_model=MarkerResponse)
async def create_marker(marker: MarkerCreate, db: Session = Depends(get_db)):
    """새 마커 생성"""
    
    db_marker = Marker(**marker.dict())
    db.add(db_marker)
    db.commit()
    db.refresh(db_marker)
    
    marker_data = MarkerResponse.from_orm(db_marker)
    marker_data.video_count = 0
    marker_data.analysis_count = 0
    
    return marker_data


@router.patch("/{marker_id}", response_model=MarkerResponse)
async def update_marker(
    marker_id: int, 
    marker_update: MarkerUpdate, 
    db: Session = Depends(get_db)
):
    """마커 정보 수정"""
    
    # 마커 존재 확인
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    # 업데이트할 필드만 수정
    update_data = marker_update.dict(exclude_unset=True)
    
    # 빈 문자열을 None으로 변환 (선택사항)
    for field, value in update_data.items():
        if isinstance(value, str) and value.strip() == "":
            update_data[field] = None
    
    # 필드 업데이트
    for field, value in update_data.items():
        if hasattr(marker, field):
            setattr(marker, field, value)
    
    # 수정 시간 업데이트
    marker.updated_at = datetime.now()
    
    try:
        db.commit()
        db.refresh(marker)
        
        # 응답 데이터 생성
        marker_data = MarkerResponse.from_orm(marker)
        marker_data.video_count = len(marker.videos)
        marker_data.analysis_count = len(marker.analyses)
        
        return marker_data
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"마커 수정 중 오류가 발생했습니다: {str(e)}")


@router.delete("/{marker_id}")
async def delete_marker(marker_id: int, db: Session = Depends(get_db)):
    """마커 삭제"""
    
    # 마커 존재 확인
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    try:
        # 관련된 비디오 수 확인
        video_count = db.query(Video).filter(Video.marker_id == marker_id).count()
        
        # 관련된 분석 수 확인
        analysis_count = db.query(Analysis).filter(Analysis.marker_id == marker_id).count()
        
        # 마커 삭제 (CASCADE로 인해 관련 데이터도 자동 삭제됨)
        db.delete(marker)
        db.commit()
        
        return {
            "message": "마커가 성공적으로 삭제되었습니다.",
            "deleted_marker_id": marker_id,
            "deleted_videos": video_count,
            "deleted_analyses": analysis_count
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"마커 삭제 중 오류가 발생했습니다: {str(e)}")


@router.get("/{marker_id}/statistics")
async def get_marker_statistics(marker_id: int, db: Session = Depends(get_db)):
    """특정 마커의 통계 정보 조회"""
    
    # 마커 존재 확인
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    # 비디오 통계
    video_stats = db.query(
        func.count(Video.id).label('total_videos'),
        func.sum(Video.file_size).label('total_size'),
        func.avg(Video.duration).label('avg_duration')
    ).filter(Video.marker_id == marker_id).first()
    
    # 분석 통계
    analysis_stats = db.query(
        func.count(Analysis.id).label('total_analyses'),
        func.avg(Analysis.confidence_score).label('avg_confidence'),
        func.sum(Analysis.total_cracks_detected).label('total_cracks'),
        func.sum(Analysis.total_crack_area).label('total_area')
    ).filter(Analysis.marker_id == marker_id).first()
    
    return {
        "marker_id": marker_id,
        "marker_title": marker.title,
        "video_statistics": {
            "total_videos": video_stats.total_videos or 0,
            "total_size_bytes": int(video_stats.total_size or 0),
            "average_duration_seconds": float(video_stats.avg_duration or 0)
        },
        "analysis_statistics": {
            "total_analyses": analysis_stats.total_analyses or 0,
            "average_confidence": float(analysis_stats.avg_confidence or 0),
            "total_cracks_detected": int(analysis_stats.total_cracks or 0),
            "total_crack_area": float(analysis_stats.total_area or 0)
        },
        "created_at": marker.created_at,
        "updated_at": marker.updated_at
    }


@router.patch("/{marker_id}/status")
async def update_marker_status(
    marker_id: int, 
    status: MarkerStatus,
    db: Session = Depends(get_db)
):
    """마커 상태만 빠르게 업데이트"""
    
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    old_status = marker.status
    marker.status = status
    marker.updated_at = datetime.now()
    
    try:
        db.commit()
        db.refresh(marker)
        
        return {
            "message": "마커 상태가 업데이트되었습니다.",
            "marker_id": marker_id,
            "old_status": old_status,
            "new_status": status,
            "updated_at": marker.updated_at
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"상태 업데이트 중 오류가 발생했습니다: {str(e)}")


@router.patch("/{marker_id}/assign")
async def assign_marker(
    marker_id: int, 
    assigned_to: str,
    db: Session = Depends(get_db)
):
    """마커 담당자 배정"""
    
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    old_assigned_to = marker.assigned_to
    marker.assigned_to = assigned_to.strip() if assigned_to.strip() else None
    marker.updated_at = datetime.now()
    
    try:
        db.commit()
        db.refresh(marker)
        
        return {
            "message": "담당자가 배정되었습니다.",
            "marker_id": marker_id,
            "old_assigned_to": old_assigned_to,
            "new_assigned_to": marker.assigned_to,
            "updated_at": marker.updated_at
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"담당자 배정 중 오류가 발생했습니다: {str(e)}")


@router.get("/search/nearby")
async def search_nearby_markers(
    lat: float = Query(..., description="위도"),
    lng: float = Query(..., description="경도"),
    radius_km: float = Query(1.0, description="검색 반경 (킬로미터)"),
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db)
):
    """특정 좌표 주변의 마커 검색"""
    
    # 간단한 거리 계산 (정확하지 않지만 데모용)
    # 실제로는 PostGIS나 다른 공간 데이터베이스를 사용하는 것이 좋음
    lat_range = radius_km / 111.0  # 대략적인 위도 1도 = 111km
    lng_range = radius_km / (111.0 * abs(lat))  # 경도는 위도에 따라 달라짐
    
    markers = db.query(Marker).filter(
        and_(
            Marker.latitude.between(lat - lat_range, lat + lat_range),
            Marker.longitude.between(lng - lng_range, lng + lng_range)
        )
    ).limit(limit).all()
    
    # 거리 계산 및 정렬 (실제 거리 계산)
    import math
    
    def calculate_distance(lat1, lng1, lat2, lng2):
        # Haversine 공식을 사용한 거리 계산
        R = 6371  # 지구 반지름 (km)
        
        lat1_rad = math.radians(lat1)
        lat2_rad = math.radians(lat2)
        delta_lat = math.radians(lat2 - lat1)
        delta_lng = math.radians(lng2 - lng1)
        
        a = (math.sin(delta_lat/2) * math.sin(delta_lat/2) + 
             math.cos(lat1_rad) * math.cos(lat2_rad) * 
             math.sin(delta_lng/2) * math.sin(delta_lng/2))
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return R * c
    
    # 거리 정보 포함한 결과 생성
    results = []
    for marker in markers:
        distance = calculate_distance(lat, lng, marker.latitude, marker.longitude)
        if distance <= radius_km:
            marker_data = MarkerResponse.from_orm(marker)
            marker_data.video_count = len(marker.videos)
            marker_data.analysis_count = len(marker.analyses)
            
            results.append({
                "marker": marker_data,
                "distance_km": round(distance, 3)
            })
    
    # 거리순으로 정렬
    results.sort(key=lambda x: x["distance_km"])
    
    return {
        "search_center": {"lat": lat, "lng": lng},
        "radius_km": radius_km,
        "total_found": len(results),
        "results": results
    }
```

---

### 17. analysis.py

- **경로:** `backend/app/api/analysis.py`
- **크기:** 10,471 characters
- **타입:** .py

```python
# backend/app/api/analysis.py (완전한 구현)
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse, StreamingResponse
from sqlalchemy.orm import Session
from typing import List
import os
import logging

from ..core.database import get_db
from ..models.video import Video
from ..models.analysis import Analysis, AnalysisStatus
from ..schemas.analysis import AnalysisCreate, AnalysisResponse, AnalysisUpdate
from ..services.ai_service import start_video_analysis

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get("/video/{video_id}", response_model=List[AnalysisResponse])
async def get_video_analyses(video_id: int, db: Session = Depends(get_db)):
    """특정 비디오의 분석 결과 목록 조회"""
    
    # 비디오 존재 확인
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    analyses = db.query(Analysis).filter(Analysis.video_id == video_id).order_by(Analysis.created_at.desc()).all()
    
    return [AnalysisResponse.from_orm(analysis) for analysis in analyses]

@router.get("/{analysis_id}", response_model=AnalysisResponse)
async def get_analysis(analysis_id: int, db: Session = Depends(get_db)):
    """특정 분석 결과 상세 조회"""
    
    analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
    if not analysis:
        raise HTTPException(status_code=404, detail="분석 결과를 찾을 수 없습니다.")
    
    return AnalysisResponse.from_orm(analysis)

@router.post("/start/{video_id}", response_model=AnalysisResponse)
async def start_analysis(
    video_id: int, 
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """비디오 AI 분석 시작"""
    
    # 비디오 존재 확인
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    # 이미 진행 중인 분석이 있는지 확인
    existing_analysis = db.query(Analysis).filter(
        Analysis.video_id == video_id,
        Analysis.status.in_([AnalysisStatus.PENDING, AnalysisStatus.PROCESSING])
    ).first()
    
    if existing_analysis:
        logger.info(f"기존 진행 중인 분석 반환: {existing_analysis.id}")
        return AnalysisResponse.from_orm(existing_analysis)
    
    # 새 분석 생성
    analysis_data = AnalysisCreate(
        marker_id=video.marker_id,
        video_id=video_id
    )
    
    db_analysis = Analysis(**analysis_data.dict())
    db_analysis.status = AnalysisStatus.PENDING
    db.add(db_analysis)
    db.commit()
    db.refresh(db_analysis)
    
    logger.info(f"새 분석 시작: {db_analysis.id} for video {video_id}")
    
    # 백그라운드에서 AI 분석 시작
    background_tasks.add_task(start_video_analysis, db_analysis.id, video.file_path)
    
    return AnalysisResponse.from_orm(db_analysis)

@router.get("/{analysis_id}/result-video")
async def get_analysis_result_video(analysis_id: int, db: Session = Depends(get_db)):
    """분석 결과 비디오 스트리밍"""
    
    analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
    if not analysis:
        raise HTTPException(status_code=404, detail="분석 결과를 찾을 수 없습니다.")
    
    if analysis.status != AnalysisStatus.COMPLETED:
        raise HTTPException(status_code=400, detail="분석이 완료되지 않았습니다.")
    
    if not analysis.result_video_path or not os.path.exists(analysis.result_video_path):
        raise HTTPException(status_code=404, detail="분석 결과 비디오 파일을 찾을 수 없습니다.")
    
    # Range Request 지원하는 스트리밍
    def iter_file():
        with open(analysis.result_video_path, 'rb') as f:
            while chunk := f.read(8192):
                yield chunk
    
    file_size = os.path.getsize(analysis.result_video_path)
    headers = {
        'Content-Length': str(file_size),
        'Content-Type': 'video/mp4',
        'Accept-Ranges': 'bytes',
        'Cache-Control': 'public, max-age=3600'
    }
    
    return StreamingResponse(iter_file(), headers=headers)

@router.get("/{analysis_id}/comparison")
async def get_video_comparison_data(analysis_id: int, db: Session = Depends(get_db)):
    """원본 비디오와 분석 결과 비디오 비교 정보"""
    
    try:
        analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
        if not analysis:
            logger.error(f"분석 결과를 찾을 수 없음: {analysis_id}")
            raise HTTPException(status_code=404, detail="분석 결과를 찾을 수 없습니다.")
        
        # 원본 비디오 정보
        original_video = analysis.video
        if not original_video:
            logger.error(f"원본 비디오를 찾을 수 없음: analysis_id={analysis_id}")
            raise HTTPException(status_code=404, detail="원본 비디오를 찾을 수 없습니다.")
        
        # 결과 비디오 경로 확인
        has_result_video = (
            analysis.status == AnalysisStatus.COMPLETED and 
            analysis.result_video_path and 
            os.path.exists(analysis.result_video_path)
        )
        
        logger.info(f"비교 데이터 생성 - analysis_id: {analysis_id}, status: {analysis.status}, has_result: {has_result_video}")
        
        response_data = {
            "analysis_id": analysis_id,
            "status": analysis.status.value if hasattr(analysis.status, 'value') else str(analysis.status),
            "progress": analysis.progress or 0,
            "original_video": {
                "id": original_video.id,
                "filename": original_video.original_filename,
                "stream_url": f"/api/videos/{original_video.id}/stream",
                "duration": original_video.duration,
                "size": original_video.file_size
            },
            "result_video": {
                "available": has_result_video,
                "stream_url": f"/api/analysis/{analysis_id}/result-video" if has_result_video else None
            }
        }
        
        # 분석 완료시 요약 정보 추가
        if analysis.status == AnalysisStatus.COMPLETED:
            response_data["analysis_summary"] = {
                "total_cracks": analysis.total_cracks_detected or 0,
                "total_area": analysis.total_crack_area or 0,
                "confidence": analysis.confidence_score or 0,
                "severity": None
            }
            
            # severity_analysis가 dict인 경우 처리
            if analysis.severity_analysis:
                if isinstance(analysis.severity_analysis, dict):
                    response_data["analysis_summary"]["severity"] = analysis.severity_analysis.get("overall_severity")
                else:
                    # JSON 문자열인 경우
                    try:
                        import json
                        severity_data = json.loads(analysis.severity_analysis)
                        response_data["analysis_summary"]["severity"] = severity_data.get("overall_severity")
                    except:
                        pass
        
        logger.info(f"응답 데이터: {response_data}")
        return response_data
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"비교 데이터 생성 중 오류: {e}")
        raise HTTPException(status_code=500, detail=f"비교 데이터 생성 중 오류가 발생했습니다: {str(e)}")

@router.patch("/{analysis_id}", response_model=AnalysisResponse)
async def update_analysis(
    analysis_id: int,
    analysis_update: AnalysisUpdate,
    db: Session = Depends(get_db)
):
    """분석 결과 업데이트 (AI 서비스에서 사용)"""
    
    analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
    if not analysis:
        raise HTTPException(status_code=404, detail="분석 결과를 찾을 수 없습니다.")
    
    # 업데이트할 필드만 수정
    update_data = analysis_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        if field in ["crack_details", "material_estimation", "severity_analysis"] and value is not None:
            # Pydantic 모델을 dict로 변환
            if hasattr(value, 'dict'):
                value = value.dict()
            elif isinstance(value, list) and value and hasattr(value[0], 'dict'):
                value = [item.dict() for item in value]
        setattr(analysis, field, value)
    
    # 완료 시간 설정
    if update_data.get("status") == AnalysisStatus.COMPLETED:
        from datetime import datetime
        analysis.completed_at = datetime.now()
    
    try:
        db.commit()
        db.refresh(analysis)
        return AnalysisResponse.from_orm(analysis)
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"분석 결과 업데이트 중 오류가 발생했습니다: {str(e)}")

@router.delete("/{analysis_id}")
async def delete_analysis(analysis_id: int, db: Session = Depends(get_db)):
    """분석 결과 삭제"""
    
    analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
    if not analysis:
        raise HTTPException(status_code=404, detail="분석 결과를 찾을 수 없습니다.")
    
    # 결과 파일도 삭제
    if analysis.result_video_path and os.path.exists(analysis.result_video_path):
        try:
            os.remove(analysis.result_video_path)
            logger.info(f"분석 결과 파일 삭제: {analysis.result_video_path}")
        except Exception as e:
            logger.warning(f"분석 결과 파일 삭제 실패: {e}")
    
    try:
        db.delete(analysis)
        db.commit()
        
        return {
            "message": "분석 결과가 성공적으로 삭제되었습니다.",
            "deleted_analysis_id": analysis_id
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"분석 결과 삭제 중 오류가 발생했습니다: {str(e)}")

@router.get("/")
async def list_analyses(
    skip: int = 0,
    limit: int = 50,
    status: str = None,
    marker_id: int = None,
    db: Session = Depends(get_db)
):
    """모든 분석 결과 목록 조회 (관리자용)"""
    
    query = db.query(Analysis)
    
    if status:
        try:
            status_enum = AnalysisStatus(status)
            query = query.filter(Analysis.status == status_enum)
        except ValueError:
            raise HTTPException(status_code=400, detail=f"유효하지 않은 상태: {status}")
    
    if marker_id:
        query = query.filter(Analysis.marker_id == marker_id)
    
    analyses = query.order_by(Analysis.created_at.desc()).offset(skip).limit(limit).all()
    
    result = []
    for analysis in analyses:
        analysis_data = AnalysisResponse.from_orm(analysis)
        result.append({
            "analysis": analysis_data,
            "marker_title": analysis.marker.title if analysis.marker else None,
            "video_filename": analysis.video.original_filename if analysis.video else None
        })
    
    return {
        "total": query.count(),
        "analyses": result
    }
```

---

### 18. dashboard.py

- **경로:** `backend/app/api/dashboard.py`
- **크기:** 2,692 characters
- **타입:** .py

```python
# backend/app/api/dashboard.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from sqlalchemy import func
from datetime import datetime, timedelta
from typing import Dict, Any, List

from ..core.database import get_db
from ..models.marker import Marker, MarkerStatus, MarkerPriority
from ..models.video import Video
from ..models.analysis import Analysis

router = APIRouter()


@router.get("/stats")
async def get_dashboard_stats(db: Session = Depends(get_db)):
    """대시보드 통계 데이터 조회"""
    
    # 전체 마커 수
    total_markers = db.query(Marker).count()
    
    # 긴급 이슈 수
    urgent_issues = db.query(Marker).filter(
        Marker.priority == MarkerPriority.URGENT,
        Marker.status != MarkerStatus.COMPLETED
    ).count()
    
    # 주간 완료 수 (지난 7일)
    week_ago = datetime.now() - timedelta(days=7)
    weekly_completed = db.query(Marker).filter(
        Marker.status == MarkerStatus.COMPLETED,
        Marker.updated_at >= week_ago
    ).count()
    
    # 대기 중인 마커 수
    pending_markers = db.query(Marker).filter(
        Marker.status == MarkerStatus.PENDING
    ).count()
    
    # 활성 마커 수 (예시로 진행 중인 마커)
    active_markers = db.query(Marker).filter(
        Marker.status == MarkerStatus.PROGRESS
    ).count()
    
    return {
        "total_markers": total_markers,
        "urgent_issues": urgent_issues,
        "weekly_completed": weekly_completed,
        "pending_markers": pending_markers,
        "active_markers": active_markers
    }


@router.get("/recent-activities")
async def get_recent_activities(limit: int = 10, db: Session = Depends(get_db)):
    """최근 활동 조회"""
    
    # 최근 마커들을 생성일 기준으로 조회
    recent_markers = db.query(Marker).order_by(
        Marker.created_at.desc()
    ).limit(limit).all()
    
    activities = []
    for marker in recent_markers:
        activities.append({
            "id": marker.id,
            "type": "marker_created",
            "message": f"{marker.created_by}가 {marker.road_name or '도로'}에서 {marker.issue_type}을 등록했습니다.",
            "user": marker.created_by,
            "location": marker.road_name or marker.address,
            "timestamp": marker.created_at,
            "marker_id": marker.id
        })
    
    return {"activities": activities}


@router.get("/region-stats")
async def get_region_stats(db: Session = Depends(get_db)):
    """지역별 통계"""
    
    # 간단한 지역별 집계 (실제로는 주소를 파싱해서 시/도별로 집계)
    regions = [
        {"name": "서울", "count": 234},
        {"name": "경기", "count": 189}, 
        {"name": "부산", "count": 156},
        {"name": "인천", "count": 98},
        {"name": "대구", "count": 87},
        {"name": "기타", "count": 123}
    ]
    
    return {"regions": regions}



```

---

### 19. __init__.py

- **경로:** `backend/app/api/__init__.py`
- **크기:** 32 characters
- **타입:** .py

```python
# API 라우터들은 main.py에서 직접 import

```

---

### 20. videos.py

- **경로:** `backend/app/api/videos.py`
- **크기:** 23,145 characters
- **타입:** .py

```python
# backend/app/api/videos.py (완전한 버전)
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form, Request
from fastapi.responses import StreamingResponse, FileResponse
from sqlalchemy.orm import Session
from typing import List
import os
import uuid
import aiofiles
from datetime import datetime
import mimetypes

from ..core.database import get_db
from ..core.config import settings
from ..models.marker import Marker
from ..models.video import Video
from ..schemas.video import VideoCreate, VideoResponse
from ..utils.file_utils import validate_video_file, get_video_metadata
from ..utils.video_utils import video_processor
import logging

logger = logging.getLogger(__name__)
router = APIRouter()

@router.post("/upload/{marker_id}", response_model=VideoResponse)
async def upload_video(
    marker_id: int,
    file: UploadFile = File(...),
    description: str = Form(None),
    uploaded_by: str = Form(...),
    db: Session = Depends(get_db)
):
    """비디오 파일 업로드 및 웹 호환성 변환"""
    
    # 마커 존재 확인
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    # 파일 유효성 검사
    if not validate_video_file(file):
        raise HTTPException(status_code=400, detail="지원하지 않는 비디오 형식입니다.")
    
    # 파일 크기 체크
    if file.size and file.size > settings.MAX_UPLOAD_SIZE:
        raise HTTPException(status_code=400, detail=f"파일 크기가 너무 큽니다. 최대 {settings.MAX_UPLOAD_SIZE // (1024*1024)}MB")
    
    # 고유 파일명 생성
    file_extension = os.path.splitext(file.filename or "")[1]
    unique_id = uuid.uuid4()
    original_filename = f"original_{unique_id}{file_extension}"
    web_filename = f"web_{unique_id}.mp4"
    
    # 저장 경로 설정
    upload_dir = os.path.join(settings.UPLOAD_FOLDER, "videos")
    os.makedirs(upload_dir, exist_ok=True)
    
    original_path = os.path.join(upload_dir, original_filename)
    web_compatible_path = os.path.join(upload_dir, web_filename)
    
    try:
        # 1. 원본 파일 저장
        logger.info(f"📥 비디오 업로드 시작: {file.filename}")
        
        async with aiofiles.open(original_path, 'wb') as f:
            content = await file.read()
            await f.write(content)
        
        file_size = len(content)
        logger.info(f"✅ 원본 파일 저장 완료: {original_path}")
        
        # 2. 웹 호환성 검사
        compatibility = video_processor.validate_web_compatibility(original_path)
        logger.info(f"🔍 웹 호환성 검사: {compatibility}")
        
        # 3. 웹 호환 형식으로 변환 (필요한 경우)
        final_video_path = original_path
        web_converted = False
        
        if not compatibility.get("compatible", False):
            logger.info("🔄 웹 호환 형식으로 변환 시작...")
            
            conversion_result = video_processor.convert_to_web_compatible(
                original_path, 
                web_compatible_path
            )
            
            if conversion_result["success"]:
                final_video_path = web_compatible_path
                web_converted = True
                file_size = conversion_result["file_size"]
                logger.info("✅ 웹 호환 변환 완료")
            else:
                logger.warning(f"⚠️ 웹 호환 변환 실패, 원본 사용: {conversion_result.get('error')}")
        else:
            logger.info("✅ 이미 웹 호환 형식")
        
        # 4. 비디오 메타데이터 추출
        try:
            metadata = get_video_metadata(final_video_path)
        except Exception as e:
            logger.warning(f"메타데이터 추출 실패: {e}")
            metadata = {}
        
        # 5. 데이터베이스에 저장
        video_data = VideoCreate(
            filename=web_filename if web_converted else original_filename,
            original_filename=file.filename or "unknown.mp4",
            file_path=final_video_path,
            file_size=file_size,
            marker_id=marker_id,
            uploaded_by=uploaded_by,
            description=description,
            duration=metadata.get("duration"),
            width=metadata.get("width"),
            height=metadata.get("height"),
            fps=metadata.get("fps")
        )
        
        db_video = Video(**video_data.dict())
        db.add(db_video)
        db.commit()
        db.refresh(db_video)
        
        # 6. 불필요한 파일 정리
        if web_converted and os.path.exists(original_path):
            try:
                os.remove(original_path)
                logger.info("🗑️ 원본 파일 삭제 (웹 호환 버전 생성됨)")
            except:
                pass
        
        video_response = VideoResponse.from_orm(db_video)
        video_response.has_analysis = False
        
        logger.info(f"🎉 비디오 업로드 및 처리 완료: ID={db_video.id}")
        
        return video_response
        
    except Exception as e:
        # 실패 시 파일 정리
        for path in [original_path, web_compatible_path]:
            if os.path.exists(path):
                try:
                    os.remove(path)
                except:
                    pass
        
        if 'db_video' in locals():
            try:
                db.rollback()
            except:
                pass
        
        logger.error(f"💥 비디오 업로드 실패: {e}")
        raise HTTPException(status_code=500, detail=f"비디오 업로드 중 오류: {str(e)}")

@router.get("/{video_id}/stream")
async def stream_video(request: Request, video_id: int, db: Session = Depends(get_db)):
    """웹 호환 비디오 스트리밍 (Range Request 지원)"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    if not os.path.exists(video.file_path):
        raise HTTPException(status_code=404, detail="비디오 파일을 찾을 수 없습니다.")
    
    # Range Request 지원 (비디오 스트리밍)
    file_size = os.path.getsize(video.file_path)
    range_header = request.headers.get('range')
    
    if range_header:
        # Range Request 처리
        range_match = range_header.replace('bytes=', '').split('-')
        start = int(range_match[0]) if range_match[0] else 0
        end = int(range_match[1]) if range_match[1] else file_size - 1
        end = min(end, file_size - 1)
        
        content_length = end - start + 1
        
        def iter_file_range():
            with open(video.file_path, 'rb') as f:
                f.seek(start)
                remaining = content_length
                while remaining:
                    chunk_size = min(8192, remaining)
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    remaining -= len(chunk)
                    yield chunk
        
        headers = {
            'Content-Range': f'bytes {start}-{end}/{file_size}',
            'Accept-Ranges': 'bytes',
            'Content-Length': str(content_length),
            'Content-Type': 'video/mp4',
            'Cache-Control': 'public, max-age=3600'
        }
        
        return StreamingResponse(
            iter_file_range(), 
            status_code=206,
            headers=headers
        )
    else:
        # 전체 파일 스트리밍
        def iter_file():
            with open(video.file_path, 'rb') as f:
                while chunk := f.read(8192):
                    yield chunk
        
        headers = {
            'Content-Length': str(file_size),
            'Content-Type': 'video/mp4',
            'Accept-Ranges': 'bytes',
            'Cache-Control': 'public, max-age=3600'
        }
        
        return StreamingResponse(iter_file(), headers=headers)

@router.get("/{video_id}/download")
async def download_video(video_id: int, db: Session = Depends(get_db)):
    """비디오 다운로드"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    if not os.path.exists(video.file_path):
        raise HTTPException(status_code=404, detail="비디오 파일을 찾을 수 없습니다.")
    
    return FileResponse(
        video.file_path,
        media_type="video/mp4",
        filename=video.original_filename,
        headers={"Content-Disposition": f"attachment; filename={video.original_filename}"}
    )

@router.get("/{video_id}/info")
async def get_video_info(video_id: int, db: Session = Depends(get_db)):
    """비디오 상세 정보 및 웹 호환성 체크"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    if not os.path.exists(video.file_path):
        raise HTTPException(status_code=404, detail="비디오 파일을 찾을 수 없습니다.")
    
    # 웹 호환성 검사
    compatibility = video_processor.validate_web_compatibility(video.file_path)
    
    # 파일 정보
    file_stats = os.stat(video.file_path)
    
    return {
        "video_id": video_id,
        "filename": video.original_filename,
        "file_size": video.file_size,
        "duration": video.duration,
        "resolution": f"{video.width}x{video.height}" if video.width and video.height else None,
        "fps": video.fps,
        "uploaded_by": video.uploaded_by,
        "created_at": video.created_at,
        "web_compatibility": compatibility,
        "file_exists": True,
        "last_modified": file_stats.st_mtime
    }

@router.get("/marker/{marker_id}", response_model=List[VideoResponse])
async def get_marker_videos(marker_id: int, db: Session = Depends(get_db)):
    """특정 마커의 비디오 목록 조회"""
    
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    videos = db.query(Video).filter(Video.marker_id == marker_id).order_by(Video.created_at.desc()).all()
    
    result = []
    for video in videos:
        video_data = VideoResponse.from_orm(video)
        video_data.has_analysis = len(video.analyses) > 0
        result.append(video_data)
    
    return result


@router.get("/{video_id}", response_model=VideoResponse)
async def get_video(video_id: int, db: Session = Depends(get_db)):
    """특정 비디오 상세 조회"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    video_data = VideoResponse.from_orm(video)
    video_data.has_analysis = len(video.analyses) > 0
    
    return video_data


@router.post("/upload/{marker_id}", response_model=VideoResponse)
async def upload_video(
    marker_id: int,
    file: UploadFile = File(...),
    description: str = Form(None),
    uploaded_by: str = Form(...),
    db: Session = Depends(get_db)
):
    """비디오 파일 업로드"""
    
    # 마커 존재 확인
    marker = db.query(Marker).filter(Marker.id == marker_id).first()
    if not marker:
        raise HTTPException(status_code=404, detail="마커를 찾을 수 없습니다.")
    
    # 파일 유효성 검사
    if not validate_video_file(file):
        raise HTTPException(status_code=400, detail="지원하지 않는 비디오 형식입니다.")
    
    # 파일 크기 체크
    if file.size and file.size > settings.MAX_UPLOAD_SIZE:
        raise HTTPException(status_code=400, detail=f"파일 크기가 너무 큽니다. 최대 {settings.MAX_UPLOAD_SIZE // (1024*1024)}MB")
    
    # 고유 파일명 생성
    file_extension = os.path.splitext(file.filename or "")[1]
    if not file_extension:
        file_extension = ".mp4"  # 기본 확장자
    
    unique_filename = f"{uuid.uuid4()}{file_extension}"
    
    # 저장 경로 설정
    upload_dir = os.path.join(settings.UPLOAD_FOLDER, "videos")
    os.makedirs(upload_dir, exist_ok=True)
    file_path = os.path.join(upload_dir, unique_filename)
    
    # 파일 저장
    try:
        async with aiofiles.open(file_path, 'wb') as f:
            content = await file.read()
            await f.write(content)
        
        file_size = len(content)
        
    except Exception as e:
        # 파일 저장 실패 시 정리
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
            except:
                pass
        raise HTTPException(status_code=500, detail=f"파일 저장 중 오류가 발생했습니다: {str(e)}")
    
    # 비디오 메타데이터 추출
    try:
        metadata = get_video_metadata(file_path)
    except Exception as e:
        print(f"메타데이터 추출 실패: {e}")
        metadata = {}
    
    # 데이터베이스에 저장
    try:
        video_data = VideoCreate(
            filename=unique_filename,
            original_filename=file.filename or "unknown.mp4",
            file_path=file_path,
            file_size=file_size,
            marker_id=marker_id,
            uploaded_by=uploaded_by,
            description=description,
            duration=metadata.get("duration"),
            width=metadata.get("width"),
            height=metadata.get("height"),
            fps=metadata.get("fps")
        )
        
        db_video = Video(**video_data.dict())
        db.add(db_video)
        db.commit()
        db.refresh(db_video)
        
        video_response = VideoResponse.from_orm(db_video)
        video_response.has_analysis = False
        
        return video_response
        
    except Exception as e:
        # DB 저장 실패 시 파일 정리
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
            except:
                pass
        db.rollback()
        raise HTTPException(status_code=500, detail=f"데이터베이스 저장 중 오류가 발생했습니다: {str(e)}")


@router.get("/{video_id}/stream")
async def stream_video(request: Request, video_id: int, db: Session = Depends(get_db)):
    """웹 호환 비디오 스트리밍 (Range Request 지원)"""
    
    try:
        video = db.query(Video).filter(Video.id == video_id).first()
        if not video:
            logger.error(f"비디오를 찾을 수 없음: {video_id}")
            raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
        
        if not os.path.exists(video.file_path):
            logger.error(f"비디오 파일이 존재하지 않음: {video.file_path}")
            raise HTTPException(status_code=404, detail="비디오 파일을 찾을 수 없습니다.")
        
        logger.info(f"비디오 스트리밍 요청: {video_id} -> {video.file_path}")
        
        # Range Request 지원 (비디오 스트리밍)
        file_size = os.path.getsize(video.file_path)
        range_header = request.headers.get('range')
        
        if range_header:
            # Range Request 처리
            try:
                range_match = range_header.replace('bytes=', '').split('-')
                start = int(range_match[0]) if range_match[0] else 0
                end = int(range_match[1]) if range_match[1] else file_size - 1
                end = min(end, file_size - 1)
                
                content_length = end - start + 1
                
                def iter_file_range():
                    with open(video.file_path, 'rb') as f:
                        f.seek(start)
                        remaining = content_length
                        while remaining:
                            chunk_size = min(8192, remaining)
                            chunk = f.read(chunk_size)
                            if not chunk:
                                break
                            remaining -= len(chunk)
                            yield chunk
                
                headers = {
                    'Content-Range': f'bytes {start}-{end}/{file_size}',
                    'Accept-Ranges': 'bytes',
                    'Content-Length': str(content_length),
                    'Content-Type': 'video/mp4',
                    'Cache-Control': 'public, max-age=3600'
                }
                
                logger.info(f"Range Request: {start}-{end}/{file_size}")
                
                return StreamingResponse(
                    iter_file_range(), 
                    status_code=206,
                    headers=headers
                )
            except Exception as e:
                logger.error(f"Range Request 처리 실패: {e}")
                # Range 요청 실패시 전체 파일로 fallback
        
        # 전체 파일 스트리밍
        def iter_file():
            try:
                with open(video.file_path, 'rb') as f:
                    while chunk := f.read(8192):
                        yield chunk
            except Exception as e:
                logger.error(f"파일 읽기 오류: {e}")
                raise
        
        headers = {
            'Content-Length': str(file_size),
            'Content-Type': 'video/mp4',
            'Accept-Ranges': 'bytes',
            'Cache-Control': 'public, max-age=3600'
        }
        
        logger.info(f"전체 파일 스트리밍: {file_size} bytes")
        
        return StreamingResponse(iter_file(), headers=headers)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"비디오 스트리밍 중 오류: {e}")
        raise HTTPException(status_code=500, detail=f"비디오 스트리밍 중 오류가 발생했습니다: {str(e)}")


@router.get("/{video_id}/download")
async def download_video(video_id: int, db: Session = Depends(get_db)):
    """비디오 다운로드"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    if not os.path.exists(video.file_path):
        raise HTTPException(status_code=404, detail="비디오 파일을 찾을 수 없습니다.")
    
    return FileResponse(
        video.file_path,
        media_type="application/octet-stream",
        filename=video.original_filename,
        headers={"Content-Disposition": f"attachment; filename={video.original_filename}"}
    )


@router.get("/{video_id}/thumbnail")
async def get_video_thumbnail(video_id: int, db: Session = Depends(get_db)):
    """비디오 썸네일 생성/반환"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    if not os.path.exists(video.file_path):
        raise HTTPException(status_code=404, detail="비디오 파일을 찾을 수 없습니다.")
    
    # 썸네일 생성 (간단한 구현)
    thumbnail_dir = os.path.join(settings.UPLOAD_FOLDER, "thumbnails")
    os.makedirs(thumbnail_dir, exist_ok=True)
    thumbnail_path = os.path.join(thumbnail_dir, f"{video.id}.jpg")
    
    # 썸네일이 이미 있으면 반환
    if os.path.exists(thumbnail_path):
        return FileResponse(thumbnail_path, media_type="image/jpeg")
    
    try:
        # OpenCV를 사용한 썸네일 생성
        import cv2
        cap = cv2.VideoCapture(video.file_path)
        
        if cap.isOpened():
            # 중간 프레임으로 이동
            frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            middle_frame = frame_count // 2
            cap.set(cv2.CAP_PROP_POS_FRAMES, middle_frame)
            
            ret, frame = cap.read()
            if ret:
                # 썸네일 크기 조정
                height, width = frame.shape[:2]
                if width > 320:
                    ratio = 320 / width
                    new_width = 320
                    new_height = int(height * ratio)
                    frame = cv2.resize(frame, (new_width, new_height))
                
                # 썸네일 저장
                cv2.imwrite(thumbnail_path, frame)
                cap.release()
                
                return FileResponse(thumbnail_path, media_type="image/jpeg")
            
        cap.release()
        
    except Exception as e:
        print(f"썸네일 생성 실패: {e}")
    
    # 썸네일 생성 실패 시 기본 이미지 반환 (선택사항)
    raise HTTPException(status_code=404, detail="썸네일을 생성할 수 없습니다.")


@router.patch("/{video_id}", response_model=VideoResponse)
async def update_video(
    video_id: int,
    description: str = Form(None),
    db: Session = Depends(get_db)
):
    """비디오 정보 수정"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    if description is not None:
        video.description = description.strip() if description.strip() else None
    
    try:
        db.commit()
        db.refresh(video)
        
        video_response = VideoResponse.from_orm(video)
        video_response.has_analysis = len(video.analyses) > 0
        
        return video_response
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"비디오 정보 수정 중 오류가 발생했습니다: {str(e)}")


@router.delete("/{video_id}")
async def delete_video(video_id: int, db: Session = Depends(get_db)):
    """비디오 삭제"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    file_path = video.file_path
    original_filename = video.original_filename
    
    try:
        # 데이터베이스에서 삭제
        db.delete(video)
        db.commit()
        
        # 파일 시스템에서 파일 삭제
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
            except Exception as e:
                print(f"파일 삭제 실패 (무시됨): {e}")
        
        # 썸네일 삭제
        thumbnail_path = os.path.join(settings.UPLOAD_FOLDER, "thumbnails", f"{video_id}.jpg")
        if os.path.exists(thumbnail_path):
            try:
                os.remove(thumbnail_path)
            except Exception as e:
                print(f"썸네일 삭제 실패 (무시됨): {e}")
        
        return {
            "message": "비디오가 성공적으로 삭제되었습니다.",
            "deleted_video_id": video_id,
            "filename": original_filename
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"비디오 삭제 중 오류가 발생했습니다: {str(e)}")


@router.get("/")
async def list_all_videos(
    skip: int = 0,
    limit: int = 50,
    marker_id: int = None,
    uploaded_by: str = None,
    db: Session = Depends(get_db)
):
    """모든 비디오 목록 조회 (관리자용)"""
    
    query = db.query(Video)
    
    if marker_id:
        query = query.filter(Video.marker_id == marker_id)
    
    if uploaded_by:
        query = query.filter(Video.uploaded_by.ilike(f"%{uploaded_by}%"))
    
    videos = query.order_by(Video.created_at.desc()).offset(skip).limit(limit).all()
    
    result = []
    for video in videos:
        video_data = VideoResponse.from_orm(video)
        video_data.has_analysis = len(video.analyses) > 0
        result.append({
            "video": video_data,
            "marker_title": video.marker.title if video.marker else None
        })
    
    return {
        "total": query.count(),
        "videos": result
    }
@router.get("/{video_id}")
async def get_video_info(video_id: int, db: Session = Depends(get_db)):
    """비디오 정보 조회 (디버깅용)"""
    
    video = db.query(Video).filter(Video.id == video_id).first()
    if not video:
        raise HTTPException(status_code=404, detail="비디오를 찾을 수 없습니다.")
    
    file_exists = os.path.exists(video.file_path) if video.file_path else False
    
    return {
        "id": video.id,
        "filename": video.filename,
        "original_filename": video.original_filename,
        "file_path": video.file_path,
        "file_exists": file_exists,
        "file_size": video.file_size,
        "duration": video.duration,
        "width": video.width,
        "height": video.height,
        "fps": video.fps,
        "marker_id": video.marker_id,
        "uploaded_by": video.uploaded_by,
        "created_at": video.created_at,
        "has_analysis": len(video.analyses) > 0,
        "stream_url": f"/api/videos/{video.id}/stream"
    }
```

---

### 21. code_collector.py

- **경로:** `code_collector.py`
- **크기:** 6,472 characters
- **타입:** .py

```python
#!/usr/bin/env python3
import os
import pathlib
from typing import List, Dict, Optional

def collect_project_code(
    project_dir: str,
    output_file: str = "collected_code.md",
    include_extensions: List[str] = None,
    exclude_dirs: List[str] = None,
    max_file_size: int = 100000  # 100KB
) -> None:
    """
    프로젝트 디렉토리의 코드를 수집하여 LLM 입력용 마크다운 파일로 생성
    
    Args:
        project_dir: 프로젝트 루트 디렉토리
        output_file: 출력 파일명
        include_extensions: 포함할 파일 확장자 (None이면 기본값 사용)
        exclude_dirs: 제외할 디렉토리 목록
        max_file_size: 최대 파일 크기 (바이트)
    """
    
    if include_extensions is None:
        include_extensions = [
            '.py', '.ts', '.tsx', '.js', '.jsx',  # 주요 소스코드
            '.sql', '.json', '.yml', '.yaml',     # 설정 및 데이터
            '.md', '.txt'                         # 문서
        ]
    
    if exclude_dirs is None:
        exclude_dirs = [
            'node_modules', 'venv', '__pycache__', '.git',
            'uploads', 'analysis_results', 'videos', 'public',
            '.next', 'dist', 'build'
        ]
    
    collected_files = []
    
    # 파일 수집
    for root, dirs, files in os.walk(project_dir):
        # 제외 디렉토리 필터링
        dirs[:] = [d for d in dirs if d not in exclude_dirs]
        
        for file in files:
            if any(file.endswith(ext) for ext in include_extensions):
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, project_dir)
                
                try:
                    # 파일 크기 확인
                    if os.path.getsize(file_path) > max_file_size:
                        print(f"파일 크기가 큼 (건너뜀): {rel_path}")
                        continue
                    
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    # 파일 정보 수집
                    collected_files.append({
                        'filename': file,
                        'path': rel_path,
                        'content': content,
                        'extension': pathlib.Path(file).suffix,
                        'size': len(content)
                    })
                    
                except Exception as e:
                    print(f"파일 읽기 오류: {rel_path} - {e}")
    
    # 우선순위별 정렬
    def get_priority(file_info):
        priority_map = {
            # 설정 파일들
            'main.py': 1, 'app.py': 1, 'App.tsx': 1, 'index.tsx': 1,
            'package.json': 2, 'requirements.txt': 2, 'docker-compose.yml': 2,
            # 모델 및 스키마
            '.py': 3 if 'models' in file_info['path'] else 5,
            '.ts': 3 if 'types' in file_info['path'] else 5,
            # API 및 서비스
            '.py': 4 if 'api' in file_info['path'] or 'services' in file_info['path'] else 5,
            '.ts': 4 if 'services' in file_info['path'] else 5,
            # 기타
            '.md': 10, '.txt': 10, '.json': 6, '.sql': 7
        }
        
        # 파일명 기준 우선순위
        if file_info['filename'] in priority_map:
            return priority_map[file_info['filename']]
        
        # 확장자 기준 우선순위
        ext = file_info['extension']
        if ext in priority_map:
            return priority_map[ext]
        
        return 5  # 기본 우선순위
    
    collected_files.sort(key=get_priority)
    
    # 마크다운 파일 생성
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# 프로젝트 코드 수집 결과\n\n")
        f.write(f"**프로젝트 디렉토리:** {project_dir}\n")
        f.write(f"**수집된 파일 수:** {len(collected_files)}\n")
        f.write(f"**생성 일시:** {os.popen('date').read().strip()}\n\n")
        
        # 파일 목록 요약
        f.write("## 📋 파일 목록\n\n")
        for i, file_info in enumerate(collected_files, 1):
            f.write(f"{i}. **{file_info['filename']}** - `{file_info['path']}` ({file_info['size']:,} chars)\n")
        f.write("\n---\n\n")
        
        # 각 파일 상세 내용
        f.write("## 📁 파일 상세 내용\n\n")
        
        for i, file_info in enumerate(collected_files, 1):
            f.write(f"### {i}. {file_info['filename']}\n\n")
            f.write(f"- **경로:** `{file_info['path']}`\n")
            f.write(f"- **크기:** {file_info['size']:,} characters\n")
            f.write(f"- **타입:** {file_info['extension']}\n\n")
            
            # 언어별 코드 블록
            lang_map = {
                '.py': 'python', '.ts': 'typescript', '.tsx': 'tsx',
                '.js': 'javascript', '.jsx': 'jsx', '.sql': 'sql',
                '.json': 'json', '.yml': 'yaml', '.yaml': 'yaml',
                '.md': 'markdown', '.txt': 'text'
            }
            
            lang = lang_map.get(file_info['extension'], 'text')
            f.write(f"```{lang}\n{file_info['content']}\n```\n\n")
            f.write("---\n\n")
    
    print(f"✅ 코드 수집 완료!")
    print(f"📄 출력 파일: {output_file}")
    print(f"📊 총 {len(collected_files)}개 파일 수집")
    
    # 통계 정보
    ext_count = {}
    for file_info in collected_files:
        ext = file_info['extension']
        ext_count[ext] = ext_count.get(ext, 0) + 1
    
    print(f"📈 파일 타입별 통계:")
    for ext, count in sorted(ext_count.items()):
        print(f"  {ext}: {count}개")


def collect_road_maintenance_project(project_dir: str = "."):
    """도로 유지보수 프로젝트 전용 코드 수집"""
    
    # 프로젝트별 맞춤 설정
    include_extensions = [
        '.py', '.ts', '.tsx', '.js', '.jsx',
        '.sql', '.json', '.yml', '.yaml', '.md'
    ]
    
    exclude_dirs = [
        'node_modules', 'venv', '__pycache__', '.git',
        'uploads', 'analysis_results', 'videos', 'public',
        'logo192.png', 'logo512.png', 'favicon.ico'
    ]
    
    collect_project_code(
        project_dir=project_dir,
        output_file="road_maintenance_code.md",
        include_extensions=include_extensions,
        exclude_dirs=exclude_dirs,
        max_file_size=200000  # 200KB로 증가 (AI 모델 파일 고려)
    )


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='프로젝트 코드를 LLM 입력용으로 수집')
    parser.add_argument('--dir', '-d', default='.', help='프로젝트 디렉토리 경로')
    parser.add_argument('--output', '-o', default='collected_code.md', help='출력 파일명')
    parser.add_argument('--road-maintenance', action='store_true', 
                       help='도로 유지보수 프로젝트 전용 설정 사용')
    
    args = parser.parse_args()
    
    if args.road_maintenance:
        collect_road_maintenance_project(args.dir)
    else:
        collect_project_code(args.dir, args.output)
```

---

### 22. postcss.config.js

- **경로:** `frontend/postcss.config.js`
- **크기:** 82 characters
- **타입:** .js

```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```

---

### 23. tailwind.config.js

- **경로:** `frontend/tailwind.config.js`
- **크기:** 1,356 characters
- **타입:** .js

```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
    "./public/index.html"
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f8faff',
          100: '#e8f2ff',
          200: '#cce5ff',
          300: '#99ccff',
          400: '#66b3ff',
          500: '#667eea',
          600: '#5a67d8',
          700: '#4c51bf',
          800: '#434190',
          900: '#3c366b',
        },
        secondary: {
          50: '#fdf4ff',
          100: '#fae8ff',
          200: '#f5d0fe',
          300: '#f0abfc',
          400: '#e879f9',
          500: '#764ba2',
          600: '#c026d3',
          700: '#a21caf',
          800: '#86198f',
          900: '#701a75',
        }
      },
      fontFamily: {
        sans: ['Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
      },
      animation: {
        'fadeIn': 'fadeIn 0.5s ease-in-out',
        'slideUp': 'slideUp 0.3s ease-out',
        'spin-slow': 'spin 2s linear infinite',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(20px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        }
      }
    },
  },
  plugins: [],
}

```

---

### 24. setupTests.ts

- **경로:** `frontend/src/setupTests.ts`
- **크기:** 241 characters
- **타입:** .ts

```typescript
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

```

---

### 25. react-app-env.d.ts

- **경로:** `frontend/src/react-app-env.d.ts`
- **크기:** 40 characters
- **타입:** .ts

```typescript
/// <reference types="react-scripts" />

```

---

### 26. reportWebVitals.ts

- **경로:** `frontend/src/reportWebVitals.ts`
- **크기:** 388 characters
- **타입:** .ts

```typescript
const reportWebVitals = (onPerfEntry?: (metric: any) => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

```

---

### 27. App.test.tsx

- **경로:** `frontend/src/App.test.tsx`
- **크기:** 241 characters
- **타입:** .tsx

```tsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders app without crashing', () => {
  render(<App />);
  // 기본적인 렌더링 테스트
  expect(document.body).toBeInTheDocument();
});

```

---

### 28. helpers.ts

- **경로:** `frontend/src/utils/helpers.ts`
- **크기:** 3,530 characters
- **타입:** .ts

```typescript
// frontend/src/utils/helpers.ts
import { format, formatDistanceToNow } from 'date-fns';
import { ko } from 'date-fns/locale';

export const formatDate = (dateString: string): string => {
  return format(new Date(dateString), 'yyyy.MM.dd HH:mm', { locale: ko });
};

export const formatDateShort = (dateString: string): string => {
  return format(new Date(dateString), 'MM.dd', { locale: ko });
};

export const formatRelativeTime = (dateString: string): string => {
  return formatDistanceToNow(new Date(dateString), { addSuffix: true, locale: ko });
};

export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

export const isVideoFile = (file: File): boolean => {
  const allowedTypes = ['video/mp4', 'video/mov', 'video/avi', 'video/mkv', 'video/webm'];
  return allowedTypes.includes(file.type);
};

export const validateVideoFile = (file: File, maxSize: number = 100 * 1024 * 1024): { valid: boolean; error?: string } => {
  if (!isVideoFile(file)) {
    return { valid: false, error: '지원하지 않는 비디오 형식입니다.' };
  }
  
  if (file.size > maxSize) {
    return { valid: false, error: `파일 크기가 너무 큽니다. 최대 ${formatFileSize(maxSize)}` };
  }
  
  return { valid: true };
};

export const formatDuration = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

export const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW'
  }).format(amount);
};

export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat('ko-KR').format(num);
};

export const validateEmail = (email: string): boolean => {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
};

export const validateCoordinate = (lat: number, lng: number): boolean => {
  return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
};

export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + '...';
};

export const getStatusBadgeClass = (status: string, colorMap: Record<string, string>): string => {
  return `inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${colorMap[status] || 'bg-gray-100 text-gray-800'}`;
};

export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

export const downloadFile = (url: string, filename: string): void => {
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

export const copyToClipboard = async (text: string): Promise<boolean> => {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    console.error('Failed to copy text: ', err);
    return false;
  }
};

export const getInitials = (name: string): string => {
  return name
    .split(' ')
    .map(word => word.charAt(0))
    .join('')
    .toUpperCase()
    .slice(0, 2);
};
```

---

### 29. constants.ts

- **경로:** `frontend/src/utils/constants.ts`
- **크기:** 1,483 characters
- **타입:** .ts

```typescript
// frontend/src/utils/constants.ts
import { MarkerStatus, MarkerPriority, IssueType } from '../types/marker';
import { AnalysisStatus } from '../types/analysis';

export const MARKER_STATUS_LABELS = {
  [MarkerStatus.PENDING]: '처리 대기',
  [MarkerStatus.PROGRESS]: '작업 중',
  [MarkerStatus.COMPLETED]: '완료'
};

export const MARKER_PRIORITY_LABELS = {
  [MarkerPriority.URGENT]: '긴급',
  [MarkerPriority.HIGH]: '높음',
  [MarkerPriority.NORMAL]: '보통'
};

export const ISSUE_TYPE_LABELS = {
  [IssueType.POTHOLE]: '방사 균열',
  [IssueType.CRACK]: '도로 균열',
  [IssueType.SIGN_DAMAGE]: '표지판 손상'
};

export const ANALYSIS_STATUS_LABELS = {
  [AnalysisStatus.PENDING]: '분석 대기',
  [AnalysisStatus.PROCESSING]: '분석 중',
  [AnalysisStatus.COMPLETED]: '분석 완료',
  [AnalysisStatus.FAILED]: '분석 실패'
};

export const MARKER_STATUS_COLORS = {
  [MarkerStatus.PENDING]: 'bg-yellow-100 text-yellow-800',
  [MarkerStatus.PROGRESS]: 'bg-blue-100 text-blue-800',
  [MarkerStatus.COMPLETED]: 'bg-green-100 text-green-800'
};

export const MARKER_PRIORITY_COLORS = {
  [MarkerPriority.URGENT]: 'bg-red-100 text-red-800',
  [MarkerPriority.HIGH]: 'bg-orange-100 text-orange-800',
  [MarkerPriority.NORMAL]: 'bg-gray-100 text-gray-800'
};

export const ANALYSIS_STATUS_COLORS = {
  [AnalysisStatus.PENDING]: 'bg-gray-100 text-gray-800',
  [AnalysisStatus.PROCESSING]: 'bg-yellow-100 text-yellow-800',
  [AnalysisStatus.COMPLETED]: 'bg-green-100 text-green-800',
  [AnalysisStatus.FAILED]: 'bg-red-100 text-red-800'
};

```

---

### 30. analysis.ts

- **경로:** `frontend/src/types/analysis.ts`
- **크기:** 1,194 characters
- **타입:** .ts

```typescript
// frontend/src/types/analysis.ts
export enum AnalysisStatus {
    PENDING = 'pending',
    PROCESSING = 'processing',
    COMPLETED = 'completed',
    FAILED = 'failed'
  }
  
  export interface CrackDetail {
    crack_id: string;
    crack_type: string;
    length: number;
    width: number;
    area: number;
    severity: string;
    confidence: number;
  }
  
  export interface MaterialEstimation {
    asphalt_concrete: number;
    sealer: number;
    primer: number;
    mesh?: number;
    total_cost: number;
  }
  
  export interface SeverityAnalysis {
    overall_severity: string;
    risk_score: number;
    urgent_repairs_needed: boolean;
    estimated_repair_time: string;
  }
  
  export interface Analysis {
    id: number;
    marker_id: number;
    video_id: number;
    status: AnalysisStatus;
    progress: number;
    total_cracks_detected: number;
    total_crack_area: number;
    confidence_score: number;
    crack_details?: CrackDetail[];
    material_estimation?: MaterialEstimation;
    severity_analysis?: SeverityAnalysis;
    result_video_path?: string;
    error_message?: string;
    started_at?: string;
    completed_at?: string;
    created_at: string;
  }
```

---

### 31. dashboard.ts

- **경로:** `frontend/src/types/dashboard.ts`
- **크기:** 427 characters
- **타입:** .ts

```typescript
// frontend/src/types/dashboard.ts
export interface DashboardStats {
  total_markers: number;
  urgent_issues: number;
  weekly_completed: number;
  pending_markers: number;
  active_markers: number;
}

export interface Activity {
  id: number;
  type: string;
  message: string;
  user: string;
  location?: string;
  timestamp: string;
  marker_id?: number;
}

export interface RegionStat {
  name: string;
  count: number;
}
```

---

### 32. naver-maps.d.ts

- **경로:** `frontend/src/types/naver-maps.d.ts`
- **크기:** 4,882 characters
- **타입:** .ts

```typescript
// frontend/src/types/naver-maps.d.ts
// 네이버 지도 API TypeScript 타입 정의

declare global {
  interface Window {
    naver: any;
    navermap_authFailure?: () => void;
  }

  const naver: {
    maps: {
      // 지도 클래스
      Map: new (mapDiv: HTMLElement | string, mapOptions?: any) => NaverMap;
      
      // 좌표 클래스
      LatLng: new (lat: number, lng: number) => NaverLatLng;
      LatLngBounds: new () => NaverLatLngBounds;
      
      // 마커 클래스
      Marker: new (options: NaverMarkerOptions) => NaverMarker;
      
      // 정보창 클래스
      InfoWindow: new (options: NaverInfoWindowOptions) => NaverInfoWindow;
      
      // 유틸리티 클래스
      Size: new (width: number, height: number) => NaverSize;
      Point: new (x: number, y: number) => NaverPoint;
      
      // 이벤트 클래스
      Event: {
        addListener: (target: any, eventName: string, handler: Function) => any;
        removeListener: (listener: any) => void;
        trigger: (target: any, eventName: string, ...args: any[]) => void;
      };
      
      // 지도 타입
      MapTypeId: {
        NORMAL: string;
        TERRAIN: string;
        SATELLITE: string;
        HYBRID: string;
      };
    };
  };
}

// 네이버 지도 인터페이스 정의
export interface NaverMap {
  setCenter(latlng: NaverLatLng): void;
  getCenter(): NaverLatLng;
  setZoom(zoom: number): void;
  getZoom(): number;
  fitBounds(bounds: NaverLatLngBounds, padding?: any): void;
  setMapTypeId(mapTypeId: string): void;
  getMapTypeId(): string;
  addPane(name: string, elementOrZIndex: HTMLElement | number): void;
  removePane(name: string): void;
  refresh(): void;
  autoResize(): void;
  setSize(size: NaverSize): void;
  getSize(): NaverSize;
  destroy(): void;
}

export interface NaverLatLng {
  lat(): number;
  lng(): number;
  equals(latlng: NaverLatLng): boolean;
  toString(): string;
  clone(): NaverLatLng;
}

export interface NaverLatLngBounds {
  extend(latlng: NaverLatLng): void;
  union(bounds: NaverLatLngBounds): NaverLatLngBounds;
  intersects(bounds: NaverLatLngBounds): boolean;
  isEmpty(): boolean;
  getNE(): NaverLatLng;
  getSW(): NaverLatLng;
  getCenter(): NaverLatLng;
  hasLatLng(latlng: NaverLatLng): boolean;
}

export interface NaverMarkerOptions {
  position: NaverLatLng;
  map?: NaverMap;
  icon?: string | NaverMarkerIcon;
  title?: string;
  cursor?: string;
  clickable?: boolean;
  draggable?: boolean;
  visible?: boolean;
  zIndex?: number;
  animation?: number;
}

export interface NaverMarkerIcon {
  url?: string;
  content?: string;
  size?: NaverSize;
  scaledSize?: NaverSize;
  origin?: NaverPoint;
  anchor?: NaverPoint;
}

export interface NaverMarker {
  setPosition(position: NaverLatLng): void;
  getPosition(): NaverLatLng;
  setMap(map: NaverMap | null): void;
  getMap(): NaverMap;
  setIcon(icon: string | NaverMarkerIcon): void;
  getIcon(): string | NaverMarkerIcon;
  setTitle(title: string): void;
  getTitle(): string;
  setVisible(visible: boolean): void;
  getVisible(): boolean;
  setZIndex(zIndex: number): void;
  getZIndex(): number;
  setClickable(clickable: boolean): void;
  getClickable(): boolean;
  setDraggable(draggable: boolean): void;
  getDraggable(): boolean;
  setCursor(cursor: string): void;
  getCursor(): string;
}

export interface NaverInfoWindowOptions {
  content: string;
  maxWidth?: number;
  backgroundColor?: string;
  borderColor?: string;
  borderWidth?: number;
  anchorSize?: NaverSize;
  anchorSkew?: boolean;
  anchorColor?: string;
  pixelOffset?: NaverPoint;
  position?: NaverLatLng;
  disableAutoPan?: boolean;
  disableAnchor?: boolean;
  zIndex?: number;
}

export interface NaverInfoWindow {
  open(map: NaverMap, anchor?: NaverMarker | NaverLatLng): void;
  close(): void;
  getMap(): NaverMap;
  setContent(content: string): void;
  getContent(): string;
  setPosition(position: NaverLatLng): void;
  getPosition(): NaverLatLng;
  setZIndex(zIndex: number): void;
  getZIndex(): number;
}

export interface NaverSize {
  width: number;
  height: number;
  equals(size: NaverSize): boolean;
}

export interface NaverPoint {
  x: number;
  y: number;
  equals(point: NaverPoint): boolean;
  clone(): NaverPoint;
}

// 지도 옵션 인터페이스
export interface NaverMapOptions {
  center?: NaverLatLng;
  zoom?: number;
  mapTypeControl?: boolean;
  mapDataControl?: boolean;
  logoControl?: boolean;
  scaleControl?: boolean;
  zoomControl?: boolean;
  minZoom?: number;
  maxZoom?: number;
  draggable?: boolean;
  pinchZoom?: boolean;
  scrollWheel?: boolean;
  keyboardShortcuts?: boolean;
  disableDoubleTapZoom?: boolean;
  disableDoubleClickZoom?: boolean;
  disableTwoFingerTapZoom?: boolean;
  size?: NaverSize;
  mapTypeId?: string;
}

// 이벤트 타입
export interface NaverMapEvent {
  coord: NaverLatLng;
  point: NaverPoint;
  domEvent: Event;
}

export interface NaverMarkerEvent {
  coord: NaverLatLng;
  point: NaverPoint;
  domEvent: Event;
}

export {};
```

---

### 33. video.ts

- **경로:** `frontend/src/types/video.ts`
- **크기:** 468 characters
- **타입:** .ts

```typescript
// frontend/src/types/video.ts
export interface Video {
    id: number;
    filename: string;
    original_filename: string;
    file_size: number;
    duration?: number;
    width?: number;
    height?: number;
    fps?: number;
    marker_id: number;
    uploaded_by: string;
    description?: string;
    created_at: string;
    has_analysis: boolean;
  }
  
  export interface VideoUpload {
    file: File;
    description?: string;
    uploaded_by: string;
  }
  
```

---

### 34. marker.ts

- **경로:** `frontend/src/types/marker.ts`
- **크기:** 1,232 characters
- **타입:** .ts

```typescript
// frontend/src/types/marker.ts
export enum MarkerStatus {
    PENDING = 'pending',
    PROGRESS = 'progress',
    COMPLETED = 'completed'
  }
  
  export enum MarkerPriority {
    URGENT = 'urgent',
    HIGH = 'high',
    NORMAL = 'normal'
  }
  
  export enum IssueType {
    POTHOLE = 'pothole',
    CRACK = 'crack',
    SIGN_DAMAGE = 'sign_damage'
  }
  
  export interface Marker {
    id: number;
    title: string;
    description?: string;
    latitude: number;
    longitude: number;
    address?: string;
    road_name?: string;
    issue_type: IssueType;
    status: MarkerStatus;
    priority: MarkerPriority;
    assigned_to?: string;
    created_by: string;
    created_at: string;
    updated_at?: string;
    video_count: number;
    analysis_count: number;
  }
  
  export interface MarkerCreate {
    title: string;
    description?: string;
    latitude: number;
    longitude: number;
    address?: string;
    road_name?: string;
    issue_type: IssueType;
    priority: MarkerPriority;
    assigned_to?: string;
    created_by: string;
  }
  
  export interface MarkerUpdate {
    title?: string;
    description?: string;
    status?: MarkerStatus;
    priority?: MarkerPriority;
    assigned_to?: string;
  }
```

---

### 35. VideoComparisonPlayer.tsx

- **경로:** `frontend/src/components/video/VideoComparisonPlayer.tsx`
- **크기:** 13,640 characters
- **타입:** .tsx

```tsx
import React, { useState, useEffect } from 'react';
import { Analysis } from '../../types/analysis';
import LoadingSpinner from '../common/LoadingSpinner';

interface VideoComparisonData {
  analysis_id: number;
  status: string;
  progress: number;
  original_video: {
    id: number;
    filename: string;
    stream_url: string;
    duration: number;
    size: number;
  };
  result_video: {
    available: boolean;
    stream_url: string | null;
  };
  analysis_summary?: {
    total_cracks: number;
    total_area: number;
    confidence: number;
    severity: string | null;
  };
}

interface VideoComparisonPlayerProps {
  analysis: Analysis;
}

const VideoComparisonPlayer: React.FC<VideoComparisonPlayerProps> = ({ analysis }) => {
  const [comparisonData, setComparisonData] = useState<VideoComparisonData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'original' | 'result'>('original');

  useEffect(() => {
    fetchComparisonData();
  }, [analysis.id]);

  const fetchComparisonData = async () => {
    try {
      setLoading(true);
      setError(null);
      
      console.log(`🔍 비교 데이터 요청: /api/analysis/${analysis.id}/comparison`);
      
      const response = await fetch(`/api/analysis/${analysis.id}/comparison`);
      
      console.log(`📡 응답 상태: ${response.status} ${response.statusText}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`❌ API 오류 응답:`, errorText);
        
        if (response.status === 404) {
          throw new Error('분석 결과를 찾을 수 없습니다.');
        } else if (response.status === 500) {
          throw new Error('서버 내부 오류가 발생했습니다.');
        } else {
          throw new Error(`API 오류: ${response.status} ${response.statusText}`);
        }
      }
      
      const contentType = response.headers.get('content-type');
      console.log(`📋 응답 Content-Type: ${contentType}`);
      
      if (!contentType || !contentType.includes('application/json')) {
        const textResponse = await response.text();
        console.error(`❌ JSON이 아닌 응답:`, textResponse);
        throw new Error('서버에서 올바르지 않은 응답 형식을 반환했습니다.');
      }
      
      const data = await response.json();
      console.log(`✅ 비교 데이터 수신:`, data);
      
      setComparisonData(data);
      
      // 결과 비디오가 있으면 결과 탭으로 자동 전환
      if (data.result_video && data.result_video.available) {
        setActiveTab('result');
      }
    } catch (err) {
      console.error(`💥 비교 데이터 페치 오류:`, err);
      setError(err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center py-8">
        <LoadingSpinner text="비디오 데이터 로딩 중..." />
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-700">{error}</p>
        <button 
          onClick={fetchComparisonData}
          className="mt-2 text-red-600 hover:text-red-800 underline"
        >
          다시 시도
        </button>
      </div>
    );
  }

  if (!comparisonData) {
    return null;
  }

  const isAnalysisComplete = comparisonData.status === 'completed';
  const isAnalysisInProgress = comparisonData.status === 'processing';

  return (
    <div className="space-y-6">
      {/* 분석 상태 표시 */}
      <div className="bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-lg p-4">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-lg font-semibold text-gray-900">🤖 AI 분석 상태</h3>
          <div className="flex items-center space-x-2">
            {isAnalysisInProgress && (
              <div className="animate-spin w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full"></div>
            )}
            <span className={`px-3 py-1 rounded-full text-sm font-medium ${
              isAnalysisComplete 
                ? 'bg-green-100 text-green-800' 
                : isAnalysisInProgress 
                ? 'bg-yellow-100 text-yellow-800'
                : 'bg-gray-100 text-gray-800'
            }`}>
              {isAnalysisComplete ? '분석 완료' : isAnalysisInProgress ? '분석 중' : '대기 중'}
            </span>
          </div>
        </div>
        
        {isAnalysisInProgress && (
          <div className="mb-4">
            <div className="flex justify-between text-sm text-gray-600 mb-1">
              <span>진행률</span>
              <span>{comparisonData.progress.toFixed(1)}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div 
                className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                style={{ width: `${comparisonData.progress}%` }}
              ></div>
            </div>
          </div>
        )}

        {/* 분석 요약 */}
        {comparisonData.analysis_summary && (
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
            <div className="text-center">
              <div className="text-2xl font-bold text-blue-600">
                {comparisonData.analysis_summary.total_cracks}
              </div>
              <div className="text-sm text-gray-600">검출된 균열</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-purple-600">
                {comparisonData.analysis_summary.total_area.toFixed(1)}m²
              </div>
              <div className="text-sm text-gray-600">총 균열 면적</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold text-green-600">
                {(comparisonData.analysis_summary.confidence * 100).toFixed(0)}%
              </div>
              <div className="text-sm text-gray-600">평균 신뢰도</div>
            </div>
            <div className="text-center">
              <div className={`text-2xl font-bold ${
                comparisonData.analysis_summary.severity === '위험' 
                  ? 'text-red-600' 
                  : comparisonData.analysis_summary.severity === '보통'
                  ? 'text-yellow-600'
                  : 'text-green-600'
              }`}>
                {comparisonData.analysis_summary.severity || 'N/A'}
              </div>
              <div className="text-sm text-gray-600">심각도</div>
            </div>
          </div>
        )}
      </div>

      {/* 비디오 비교 탭 */}
      <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">
        {/* 탭 헤더 */}
        <div className="border-b border-gray-200 bg-gray-50">
          <div className="flex">
            <button
              onClick={() => setActiveTab('original')}
              className={`flex-1 px-6 py-3 text-sm font-medium transition-colors ${
                activeTab === 'original'
                  ? 'text-blue-600 border-b-2 border-blue-600 bg-white'
                  : 'text-gray-500 hover:text-gray-700'
              }`}
            >
              📹 원본 영상
            </button>
            <button
              onClick={() => setActiveTab('result')}
              disabled={!comparisonData.result_video.available}
              className={`flex-1 px-6 py-3 text-sm font-medium transition-colors ${
                activeTab === 'result'
                  ? 'text-purple-600 border-b-2 border-purple-600 bg-white'
                  : comparisonData.result_video.available
                  ? 'text-gray-500 hover:text-gray-700'
                  : 'text-gray-300 cursor-not-allowed'
              }`}
            >
              🤖 분석 결과 영상 
              {!comparisonData.result_video.available && ' (분석 중)'}
            </button>
          </div>
        </div>

        {/* 비디오 플레이어 */}
        <div className="p-6">
          {activeTab === 'original' && (
            <div className="space-y-4">
              <div className="bg-black rounded-lg overflow-hidden">
                <video
                  controls
                  className="w-full h-80"
                  key={`original-${comparisonData.original_video.id}`}
                  preload="metadata"
                  playsInline
                  style={{ maxHeight: '400px' }}
                  onLoadStart={() => console.log('🎬 비디오 로드 시작')}
                  onLoadedMetadata={() => console.log('📋 비디오 메타데이터 로드됨')}
                  onCanPlay={() => console.log('✅ 비디오 재생 준비됨')}
                  onError={(e) => {
                    console.error('❌ 비디오 로드 오류:', e);
                    console.error('비디오 URL:', comparisonData.original_video.stream_url);
                  }}
                >
                  <source 
                    src={comparisonData.original_video.stream_url} 
                    type="video/mp4"
                    onError={() => console.error('❌ MP4 소스 로드 실패')}
                  />
                  브라우저에서 비디오를 지원하지 않습니다.
                </video>
                
                {/* 디버깅 정보 */}
                <div className="mt-2 p-2 bg-gray-800 text-green-400 text-xs font-mono">
                  <div>🔗 Stream URL: {comparisonData.original_video.stream_url}</div>
                  <div>📁 Video ID: {comparisonData.original_video.id}</div>
                  <div>📏 Size: {(comparisonData.original_video.size / (1024 * 1024)).toFixed(1)} MB</div>
                </div>
              </div>
              
              <div className="bg-blue-50 rounded-lg p-4">
                <h4 className="font-medium text-blue-900 mb-2">📹 원본 영상 정보</h4>
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div>
                    <span className="text-blue-700">파일명:</span>
                    <span className="ml-2 text-blue-900">{comparisonData.original_video.filename}</span>
                  </div>
                  <div>
                    <span className="text-blue-700">파일 크기:</span>
                    <span className="ml-2 text-blue-900">
                      {(comparisonData.original_video.size / (1024 * 1024)).toFixed(1)} MB
                    </span>
                  </div>
                  <div>
                    <span className="text-blue-700">재생 시간:</span>
                    <span className="ml-2 text-blue-900">
                      {comparisonData.original_video.duration 
                        ? `${Math.floor(comparisonData.original_video.duration / 60)}:${Math.floor(comparisonData.original_video.duration % 60).toString().padStart(2, '0')}`
                        : '알 수 없음'
                      }
                    </span>
                  </div>
                  <div>
                    <span className="text-blue-700">상태:</span>
                    <span className="ml-2 text-green-600 font-medium">✅ 웹 호환</span>
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'result' && (
            <div className="space-y-4">
              {comparisonData.result_video.available ? (
                <>
                  <div className="bg-black rounded-lg overflow-hidden">
                    <video
                      controls
                      className="w-full h-80"
                      key={`result-${comparisonData.analysis_id}`}
                      preload="metadata"
                      playsInline
                      style={{ maxHeight: '400px' }}
                    >
                      <source src={comparisonData.result_video.stream_url!} type="video/mp4" />
                      브라우저에서 비디오를 지원하지 않습니다.
                    </video>
                  </div>
                  
                  <div className="bg-purple-50 rounded-lg p-4">
                    <h4 className="font-medium text-purple-900 mb-2">🤖 AI 분석 결과</h4>
                    <div className="space-y-2 text-sm text-purple-700">
                      <p>• 이 영상은 YOLO AI 모델로 분석되어 균열이 빨간색 박스로 표시됩니다.</p>
                      <p>• 각 박스에는 신뢰도가 함께 표시됩니다.</p>
                      <p>• 웹 브라우저에서 최적화된 H.264 형식으로 인코딩되었습니다.</p>
                    </div>
                  </div>
                </>
              ) : (
                <div className="text-center py-12">
                  <div className="text-6xl mb-4">🔄</div>
                  <h3 className="text-lg font-medium text-gray-900 mb-2">분석 진행 중</h3>
                  <p className="text-gray-600 mb-4">
                    AI가 영상을 분석하고 웹 호환 형식으로 변환하고 있습니다.
                  </p>
                  {isAnalysisInProgress && (
                    <div className="max-w-xs mx-auto">
                      <div className="flex justify-between text-sm text-gray-600 mb-1">
                        <span>진행률</span>
                        <span>{comparisonData.progress.toFixed(1)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div 
                          className="bg-purple-500 h-2 rounded-full transition-all duration-300"
                          style={{ width: `${comparisonData.progress}%` }}
                        ></div>
                      </div>
                      <p className="text-xs text-gray-500 mt-2">
                        {comparisonData.progress < 80 ? '프레임 분석 중...' : '웹 호환 형식 변환 중...'}
                      </p>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default VideoComparisonPlayer;
```

---

### 36. AIAnalysisResult.tsx

- **경로:** `frontend/src/components/video/AIAnalysisResult.tsx`
- **크기:** 10,248 characters
- **타입:** .tsx

```tsx
import React from 'react';
import { Analysis } from '../../types/analysis';

interface AIAnalysisResultProps {
  analysis: Analysis;
  onStartAnalysis?: () => void;
  canStartAnalysis?: boolean;
}

const AIAnalysisResult: React.FC<AIAnalysisResultProps> = ({ 
  analysis, 
  onStartAnalysis,
  canStartAnalysis = false 
}) => {
  const isCompleted = analysis.status === 'completed';
  const isProcessing = analysis.status === 'processing';
  const isFailed = analysis.status === 'failed';

  if (!isCompleted && !isProcessing && !isFailed) {
    return (
      <div className="bg-gray-50 rounded-lg p-6 text-center">
        <div className="text-4xl mb-3">🤖</div>
        <h3 className="text-lg font-medium text-gray-900 mb-2">AI 분석 대기 중</h3>
        <p className="text-gray-600 mb-4">
          이 영상은 아직 AI 분석이 시작되지 않았습니다.
        </p>
        {canStartAnalysis && onStartAnalysis && (
          <button
            onClick={onStartAnalysis}
            className="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg transition-colors"
          >
            🚀 AI 분석 시작
          </button>
        )}
      </div>
    );
  }

  if (isProcessing) {
    return (
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
        <div className="flex items-center mb-4">
          <div className="animate-spin w-6 h-6 border-2 border-yellow-500 border-t-transparent rounded-full mr-3"></div>
          <h3 className="text-lg font-semibold text-yellow-900">🤖 AI 분석 진행 중</h3>
        </div>
        
        <div className="mb-4">
          <div className="flex justify-between text-sm text-yellow-700 mb-1">
            <span>진행률</span>
            <span>{analysis.progress}%</span>
          </div>
          <div className="w-full bg-yellow-200 rounded-full h-3">
            <div 
              className="bg-yellow-500 h-3 rounded-full transition-all duration-500"
              style={{ width: `${analysis.progress}%` }}
            ></div>
          </div>
        </div>
        
        <p className="text-sm text-yellow-700">
          YOLO 모델이 영상을 프레임별로 분석하고 있습니다. 잠시만 기다려주세요.
        </p>
      </div>
    );
  }

  if (isFailed) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-6">
        <div className="flex items-center mb-3">
          <span className="text-2xl mr-3">❌</span>
          <h3 className="text-lg font-semibold text-red-900">AI 분석 실패</h3>
        </div>
        
        <p className="text-red-700 mb-3">
          {analysis.error_message || '알 수 없는 오류로 분석에 실패했습니다.'}
        </p>
        
        {canStartAnalysis && onStartAnalysis && (
          <button
            onClick={onStartAnalysis}
            className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg transition-colors text-sm"
          >
            🔄 다시 분석
          </button>
        )}
      </div>
    );
  }

  // 분석 완료 상태
  return (
    <div className="space-y-6">
      {/* 분석 요약 */}
      <div className="bg-gradient-to-br from-green-50 to-blue-50 rounded-lg p-6">
        <div className="flex items-center mb-4">
          <span className="text-2xl mr-3">✅</span>
          <h3 className="text-lg font-semibold text-gray-900">🤖 AI 분석 완료</h3>
        </div>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div className="text-center">
            <div className="text-2xl font-bold text-blue-600">{analysis.total_cracks_detected}</div>
            <div className="text-sm text-gray-600">검출된 균열</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-purple-600">{analysis.total_crack_area.toFixed(1)}m²</div>
            <div className="text-sm text-gray-600">총 균열 면적</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-green-600">{(analysis.confidence_score * 100).toFixed(0)}%</div>
            <div className="text-sm text-gray-600">평균 신뢰도</div>
          </div>
          <div className="text-center">
            <div className="text-2xl font-bold text-orange-600">100%</div>
            <div className="text-sm text-gray-600">분석 완료</div>
          </div>
        </div>
      </div>
      
      {/* 심각도 분석 */}
      {analysis.severity_analysis && (
        <div className="bg-white border border-gray-200 rounded-lg p-6">
          <h4 className="font-semibold text-gray-900 mb-4 flex items-center">
            <span className="text-xl mr-2">⚠️</span>
            심각도 분석
          </h4>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-gray-600">전체 심각도:</span>
                <span className={`font-semibold ${
                  analysis.severity_analysis.overall_severity === '위험' 
                    ? 'text-red-600' 
                    : analysis.severity_analysis.overall_severity === '보통'
                    ? 'text-yellow-600'
                    : 'text-green-600'
                }`}>
                  {analysis.severity_analysis.overall_severity}
                </span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-600">위험 점수:</span>
                <span className="font-semibold">{analysis.severity_analysis.risk_score}/100</span>
              </div>
            </div>
            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-gray-600">긴급 보수 필요:</span>
                <span className={`font-semibold ${
                  analysis.severity_analysis.urgent_repairs_needed ? 'text-red-600' : 'text-green-600'
                }`}>
                  {analysis.severity_analysis.urgent_repairs_needed ? '예' : '아니오'}
                </span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-600">예상 작업 시간:</span>
                <span className="font-semibold">{analysis.severity_analysis.estimated_repair_time}</span>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* 균열 상세 정보 */}
      {analysis.crack_details && analysis.crack_details.length > 0 && (
        <div className="bg-white border border-gray-200 rounded-lg p-6">
          <h4 className="font-semibold text-gray-900 mb-4 flex items-center">
            <span className="text-xl mr-2">🔍</span>
            검출된 균열 상세 ({analysis.crack_details.length}개)
          </h4>
          <div className="space-y-3 max-h-60 overflow-y-auto">
            {analysis.crack_details.slice(0, 5).map((crack: any, index: number) => (
              <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div className="flex-1">
                  <div className="font-medium text-gray-900">{crack.crack_type || `균열 #${index + 1}`}</div>
                  <div className="text-sm text-gray-600">
                    면적: {crack.area?.toFixed(3)}m² | 신뢰도: {(crack.confidence * 100).toFixed(1)}%
                  </div>
                </div>
                <div className={`px-2 py-1 rounded-full text-xs font-medium ${
                  crack.severity === '위험' 
                    ? 'bg-red-100 text-red-800'
                    : crack.severity === '보통'
                    ? 'bg-yellow-100 text-yellow-800'
                    : 'bg-green-100 text-green-800'
                }`}>
                  {crack.severity}
                </div>
              </div>
            ))}
            {analysis.crack_details.length > 5 && (
              <div className="text-center text-sm text-gray-500 py-2">
                + {analysis.crack_details.length - 5}개 더 있음
              </div>
            )}
          </div>
        </div>
      )}

      {/* 보수재 용량 산정 */}
      {analysis.material_estimation && (
        <div className="bg-white border border-gray-200 rounded-lg p-6">
          <h4 className="font-semibold text-gray-900 mb-4 flex items-center">
            <span className="text-xl mr-2">🧱</span>
            보수재 용량 산정
          </h4>
          <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
            <div className="text-center p-3 bg-blue-50 rounded-lg">
              <div className="text-lg font-bold text-blue-600">
                {analysis.material_estimation.asphalt_concrete}톤
              </div>
              <div className="text-sm text-blue-800">아스팔트 콘크리트</div>
            </div>
            <div className="text-center p-3 bg-green-50 rounded-lg">
              <div className="text-lg font-bold text-green-600">
                {analysis.material_estimation.sealer}L
              </div>
              <div className="text-sm text-green-800">실러</div>
            </div>
            <div className="text-center p-3 bg-purple-50 rounded-lg">
              <div className="text-lg font-bold text-purple-600">
                {analysis.material_estimation.primer}L
              </div>
              <div className="text-sm text-purple-800">프라이머</div>
            </div>
          </div>
          <div className="mt-4 pt-4 border-t border-gray-200 text-center">
            <div className="text-2xl font-bold text-gray-900">
              {analysis.material_estimation.total_cost?.toLocaleString()}원
            </div>
            <div className="text-sm text-gray-600">예상 총 비용</div>
          </div>
        </div>
      )}

      {/* 분석 시간 정보 */}
      <div className="bg-gray-50 rounded-lg p-4">
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div>
            <span className="text-gray-600">분석 시작:</span>
            <span className="ml-2 text-gray-900">
              {analysis.started_at ? new Date(analysis.started_at).toLocaleString('ko-KR') : '-'}
            </span>
          </div>
          <div>
            <span className="text-gray-600">분석 완료:</span>
            <span className="ml-2 text-gray-900">
              {analysis.completed_at ? new Date(analysis.completed_at).toLocaleString('ko-KR') : '-'}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AIAnalysisResult;
```

---

### 37. VideoPlayer.tsx

- **경로:** `frontend/src/components/video/VideoPlayer.tsx`
- **크기:** 1,277 characters
- **타입:** .tsx

```tsx
import React from 'react';
import { Video } from '../../types/video';

interface VideoPlayerProps {
  video: Video;
  showAnalysis?: boolean;
}

const VideoPlayer: React.FC<VideoPlayerProps> = ({ video, showAnalysis = false }) => {
  return (
    <div className="space-y-4">
      <div className="bg-black rounded-lg overflow-hidden">
        <video
          controls
          className="w-full h-64"
          poster="/api/videos/thumbnail/${video.id}"
        >
          <source src={`/api/videos/${video.id}/stream`} type="video/mp4" />
          브라우저에서 비디오를 지원하지 않습니다.
        </video>
      </div>
      
      <div className="bg-gray-50 rounded-lg p-4">
        <h3 className="font-medium text-gray-900 mb-2">{video.original_filename}</h3>
        <div className="grid grid-cols-2 gap-4 text-sm text-gray-600">
          <div>파일 크기: {(video.file_size / (1024 * 1024)).toFixed(2)} MB</div>
          <div>길이: {video.duration ? `${Math.floor(video.duration / 60)}:${Math.floor(video.duration % 60).toString().padStart(2, '0')}` : '알 수 없음'}</div>
          <div>해상도: {video.width && video.height ? `${video.width}x${video.height}` : '알 수 없음'}</div>
          <div>업로드: {video.uploaded_by}</div>
        </div>
      </div>
    </div>
  );
};

export default VideoPlayer;

```

---

### 38. VideoUpload.tsx

- **경로:** `frontend/src/components/video/VideoUpload.tsx`
- **크기:** 2,538 characters
- **타입:** .tsx

```tsx
import React, { useState } from 'react';

interface VideoUploadProps {
  onUpload: (file: File, description?: string) => void;
  uploading?: boolean;
}

const VideoUpload: React.FC<VideoUploadProps> = ({ onUpload, uploading = false }) => {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [description, setDescription] = useState('');

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
    }
  };

  const handleUpload = () => {
    if (selectedFile) {
      onUpload(selectedFile, description);
      setSelectedFile(null);
      setDescription('');
    }
  };

  return (
    <div className="space-y-4">
      <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center">
        <input
          type="file"
          accept="video/*"
          onChange={handleFileSelect}
          className="hidden"
          id="video-upload"
        />
        <label htmlFor="video-upload" className="cursor-pointer">
          <div className="text-4xl mb-4">🎥</div>
          <p className="text-lg font-medium text-gray-900 mb-2">비디오 파일 선택</p>
          <p className="text-sm text-gray-500">클릭하여 파일을 선택하세요</p>
        </label>
      </div>
      
      {selectedFile && (
        <div className="space-y-4">
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="font-medium text-gray-900 mb-2">선택된 파일</h4>
            <p className="text-sm text-gray-600">{selectedFile.name}</p>
            <p className="text-xs text-gray-500">
              {(selectedFile.size / (1024 * 1024)).toFixed(2)} MB
            </p>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">설명 (선택사항)</label>
            <textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              rows={2}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-primary-500 focus:border-primary-500"
              placeholder="비디오에 대한 설명을 입력하세요"
            />
          </div>
          
          <button
            onClick={handleUpload}
            disabled={uploading}
            className="w-full bg-primary-500 text-white py-2 px-4 rounded-lg hover:bg-primary-600 disabled:opacity-50"
          >
            {uploading ? '업로드 중...' : '업로드'}
          </button>
        </div>
      )}
    </div>
  );
};

export default VideoUpload;

```

---

### 39. Dashboard.tsx

- **경로:** `frontend/src/components/dashboard/Dashboard.tsx`
- **크기:** 307 characters
- **타입:** .tsx

```tsx
// frontend/src/components/dashboard/Dashboard.tsx
import React from 'react';

interface DashboardProps {
  children: React.ReactNode;
}

const Dashboard: React.FC<DashboardProps> = ({ children }) => {
  return (
    <div className="space-y-6">
      {children}
    </div>
  );
};

export default Dashboard;
```

---

### 40. ActivityList.tsx

- **경로:** `frontend/src/components/dashboard/ActivityList.tsx`
- **크기:** 3,081 characters
- **타입:** .tsx

```tsx
// frontend/src/components/dashboard/ActivityList.tsx
import React from 'react';
import { Activity } from '../../types/dashboard';
import { formatRelativeTime } from '../../utils/helpers';

interface ActivityListProps {
  activities: Activity[];
}

const ActivityList: React.FC<ActivityListProps> = ({ activities }) => {
  if (activities.length === 0) {
    return (
      <div className="p-6 text-center text-gray-500">
        <div className="text-3xl mb-2">📝</div>
        <p>최근 활동이 없습니다</p>
      </div>
    );
  }

  const getActivityIcon = (type: string) => {
    switch (type) {
      case 'marker_created':
        return '📍';
      case 'video_uploaded':
        return '🎥';
      case 'analysis_completed':
        return '🤖';
      case 'status_updated':
        return '🔄';
      default:
        return '📋';
    }
  };

  const getActivityColor = (type: string) => {
    switch (type) {
      case 'marker_created':
        return 'bg-blue-100 text-blue-800';
      case 'video_uploaded':
        return 'bg-purple-100 text-purple-800';
      case 'analysis_completed':
        return 'bg-green-100 text-green-800';
      case 'status_updated':
        return 'bg-yellow-100 text-yellow-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <div className="max-h-96 overflow-y-auto">
      <div className="divide-y divide-gray-200">
        {activities.map((activity) => (
          <div key={activity.id} className="p-4 hover:bg-gray-50 transition-colors">
            <div className="flex items-start space-x-3">
              <div className={`
                flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-sm
                ${getActivityColor(activity.type)}
              `}>
                {getActivityIcon(activity.type)}
              </div>
              
              <div className="flex-1 min-w-0">
                <p className="text-sm text-gray-900 leading-relaxed">
                  {activity.message}
                </p>
                
                <div className="flex items-center mt-1 space-x-4">
                  <span className="text-xs text-gray-500">
                    {formatRelativeTime(activity.timestamp)}
                  </span>
                  
                  {activity.location && (
                    <span className="text-xs text-gray-500 flex items-center">
                      <svg className="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                      </svg>
                      {activity.location}
                    </span>
                  )}
                </div>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default ActivityList;
```

---

### 41. StatCard.tsx

- **경로:** `frontend/src/components/dashboard/StatCard.tsx`
- **크기:** 2,531 characters
- **타입:** .tsx

```tsx
// frontend/src/components/dashboard/StatCard.tsx
import React from 'react';

interface StatCardProps {
  title: string;
  value: string | number;
  icon: string;
  color: 'blue' | 'red' | 'green' | 'yellow' | 'purple';
  change?: {
    value: number;
    type: 'increase' | 'decrease';
  };
}

const StatCard: React.FC<StatCardProps> = ({ title, value, icon, color, change }) => {
  const colorClasses = {
    blue: 'bg-blue-500 text-blue-500',
    red: 'bg-red-500 text-red-500',
    green: 'bg-green-500 text-green-500',
    yellow: 'bg-yellow-500 text-yellow-500',
    purple: 'bg-purple-500 text-purple-500',
  };

  const bgColorClass = colorClasses[color].split(' ')[0];
  const textColorClass = colorClasses[color].split(' ')[1];

  return (
    <div className="bg-white rounded-lg shadow-sm p-6 hover:shadow-md transition-shadow duration-200">
      <div className="flex items-center justify-between">
        <div className="flex-1">
          <p className="text-sm font-medium text-gray-600 mb-1">{title}</p>
          <p className="text-2xl font-bold text-gray-900">{value}</p>
          
          {change && (
            <div className="flex items-center mt-2">
              <span className={`
                inline-flex items-center text-xs font-medium
                ${change.type === 'increase' ? 'text-green-600' : 'text-red-600'}
              `}>
                {change.type === 'increase' ? (
                  <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M5.293 9.707a1 1 0 010-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 01-1.414 1.414L11 7.414V15a1 1 0 11-2 0V7.414L6.707 9.707a1 1 0 01-1.414 0z" clipRule="evenodd" />
                  </svg>
                ) : (
                  <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M14.707 10.293a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 111.414-1.414L9 12.586V5a1 1 0 012 0v7.586l2.293-2.293a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                )}
                {Math.abs(change.value)}%
              </span>
              <span className="text-xs text-gray-500 ml-1">지난주 대비</span>
            </div>
          )}
        </div>
        
        <div className={`
          w-12 h-12 rounded-lg flex items-center justify-center text-white text-xl
          ${bgColorClass}
        `}>
          {icon}
        </div>
      </div>
    </div>
  );
};

export default StatCard;

```

---

### 42. NaverMap.tsx

- **경로:** `frontend/src/components/map/NaverMap.tsx`
- **크기:** 18,440 characters
- **타입:** .tsx

```tsx
// frontend/src/components/map/NaverMap.tsx (우클릭 이벤트 추가)
import React, { useEffect, useRef, useState, useCallback } from 'react';
import { Marker as MarkerType } from '../../types/marker';

interface NaverMapProps {
  markers?: MarkerType[];
  onMarkerClick?: (marker: MarkerType) => void;
  onMapClick?: (lat: number, lng: number) => void;
  onMapRightClick?: (lat: number, lng: number) => void; // 우클릭 이벤트 추가
  height?: string;
  showControls?: boolean;
  center?: { lat: number; lng: number };
  zoom?: number;
}

const NaverMap: React.FC<NaverMapProps> = ({
  markers = [],
  onMarkerClick,
  onMapClick,
  onMapRightClick, // 새로 추가된 props
  height = '400px',
  showControls = true,
  center = { lat: 37.3595704, lng: 127.105399 },
  zoom = 15
}) => {
  const mapRef = useRef<HTMLDivElement>(null);
  const mapInstanceRef = useRef<any>(null);
  const markersRef = useRef<any[]>([]);
  const contextMenuRef = useRef<any>(null); // 컨텍스트 메뉴 참조
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [mapReady, setMapReady] = useState(false);
  const [debugInfo, setDebugInfo] = useState<string>('컴포넌트 마운트 됨');
  const [componentMounted, setComponentMounted] = useState(false);
  const [rightClickPosition, setRightClickPosition] = useState<{lat: number, lng: number} | null>(null);

  // 컨텍스트 메뉴 제거
  const removeContextMenu = useCallback(() => {
    if (contextMenuRef.current) {
      try {
        contextMenuRef.current.setMap(null);
        contextMenuRef.current = null;
      } catch (error) {
        console.error('컨텍스트 메뉴 제거 오류:', error);
      }
    }
  }, []);

  // 컨텍스트 메뉴 생성
  const createContextMenu = useCallback((position: any, lat: number, lng: number) => {
    if (!mapInstanceRef.current) return;

    const naverMaps = (window as any).naver.maps;
    
    // 기존 컨텍스트 메뉴 제거
    removeContextMenu();

    // 새 컨텍스트 메뉴 생성
    const contextMenuContent = `
      <div style="
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        padding: 0;
        min-width: 180px;
        font-size: 14px;
        z-index: 1000;
      ">
        <div style="
          padding: 12px 16px;
          border-bottom: 1px solid #eee;
          background: #f8f9fa;
          border-radius: 8px 8px 0 0;
          font-weight: 500;
          color: #495057;
        ">
          📍 위치: ${lat.toFixed(4)}, ${lng.toFixed(4)}
        </div>
        <div id="context-menu-add-marker" style="
          padding: 12px 16px;
          cursor: pointer;
          border-radius: 0 0 8px 8px;
          transition: background-color 0.2s ease;
          display: flex;
          align-items: center;
          gap: 8px;
        " onmouseover="this.style.backgroundColor='#e3f2fd'" 
           onmouseout="this.style.backgroundColor='white'">
          <span style="font-size: 16px;">📍</span>
          <span style="color: #333; font-weight: 500;">여기에 마커 추가</span>
        </div>
      </div>
    `;

    contextMenuRef.current = new naverMaps.InfoWindow({
      content: contextMenuContent,
      backgroundColor: 'transparent',
      borderWidth: 0,
      disableAnchor: true,
      pixelOffset: new naverMaps.Point(10, -10)
    });

    contextMenuRef.current.open(mapInstanceRef.current, position);

    // 컨텍스트 메뉴 클릭 이벤트 등록
    setTimeout(() => {
      const addMarkerButton = document.getElementById('context-menu-add-marker');
      if (addMarkerButton) {
        addMarkerButton.addEventListener('click', () => {
          console.log('🎯 컨텍스트 메뉴에서 마커 추가 클릭:', { lat, lng });
          removeContextMenu();
          if (onMapRightClick) {
            onMapRightClick(lat, lng);
          }
        });
      }
    }, 100);
  }, [onMapRightClick, removeContextMenu]);

  // 기존 API 확인 함수 등은 그대로 유지
  const checkAPIDirectly = useCallback((): boolean => {
    try {
      const hasNaver = typeof (window as any).naver !== 'undefined';
      const hasMaps = hasNaver && (window as any).naver.maps;
      const hasMapClass = hasMaps && typeof (window as any).naver.maps.Map === 'function';
      
      console.log('🔍 컴포넌트에서 API 직접 확인:', {
        hasNaver,
        hasMaps,
        hasMapClass,
        naverMapReady: (window as any).naverMapReady,
        mapRefCurrent: !!mapRef.current,
        componentMounted
      });
      
      return hasMapClass;
    } catch (err) {
      console.error('API 확인 중 오류:', err);
      return false;
    }
  }, [componentMounted]);

  // 지도 생성 함수 (이벤트 리스너 추가됨)
  const createMap = useCallback(() => {
    console.log('🗺️ createMap 호출 - 사전 검사 시작');

    if (mapInstanceRef.current) {
      console.log('✅ 지도 이미 생성됨, 중복 생성 방지');
      setMapReady(true);
      setIsLoading(false);
      return;
    }

    if (!componentMounted || !mapRef.current || !checkAPIDirectly()) {
      console.log('⏳ 사전 조건 미충족, 재시도 대기');
      setTimeout(() => {
        if (mapRef.current && componentMounted) {
          createMap();
        }
      }, 100);
      return;
    }

    try {
      console.log('🗺️ 지도 생성 실제 시작...');
      setDebugInfo('지도 생성 시작');

      const naverMaps = (window as any).naver.maps;
      
      const mapOptions = {
        center: new naverMaps.LatLng(center.lat, center.lng),
        zoom: zoom,
        mapTypeControl: showControls,
        mapDataControl: showControls,
        logoControl: false,
        scaleControl: showControls,
        zoomControl: showControls,
        minZoom: 6,
        maxZoom: 21
      };

      mapInstanceRef.current = new naverMaps.Map(mapRef.current, mapOptions);
      console.log('✅ 지도 인스턴스 생성!');

      const checkMapReady = () => {
        try {
          if (mapInstanceRef.current && 
              typeof mapInstanceRef.current.getCenter === 'function') {
            
            console.log('🎯 지도 완전 준비 완료!');
            setMapReady(true);
            setIsLoading(false);
            setError(null);
            setDebugInfo('지도 준비 완료');

            // 일반 클릭 이벤트
            if (onMapClick) {
              naverMaps.Event.addListener(mapInstanceRef.current, 'click', (e: any) => {
                const latlng = e.coord;
                const lat = latlng.lat();
                const lng = latlng.lng();
                console.log('🖱️ 지도 클릭:', { lat, lng });
                removeContextMenu(); // 클릭 시 컨텍스트 메뉴 제거
                onMapClick(lat, lng);
              });
            }

            // 우클릭 이벤트 (컨텍스트 메뉴)
            naverMaps.Event.addListener(mapInstanceRef.current, 'rightclick', (e: any) => {
              const latlng = e.coord;
              const lat = latlng.lat();
              const lng = latlng.lng();
              console.log('🖱️ 지도 우클릭:', { lat, lng });
              
              // 컨텍스트 메뉴 생성
              createContextMenu(latlng, lat, lng);
              
              // 기본 브라우저 컨텍스트 메뉴 방지
              e.domEvent.preventDefault();
            });

            // 지도의 다른 곳 클릭 시 컨텍스트 메뉴 제거
            naverMaps.Event.addListener(mapInstanceRef.current, 'click', () => {
              removeContextMenu();
            });

            console.log('🖱️ 모든 이벤트 리스너 등록 완료');
            return true;
          }
          return false;
        } catch (err) {
          console.error('지도 준비 확인 중 오류:', err);
          return false;
        }
      };

      // idle 이벤트 등록
      naverMaps.Event.addListener(mapInstanceRef.current, 'idle', () => {
        if (!mapReady) {
          checkMapReady();
        }
      });

      // 폴링으로 준비 상태 확인
      let checkCount = 0;
      const pollMapReady = () => {
        checkCount++;
        setDebugInfo(`지도 준비 확인 중... (${checkCount}/20)`);
        
        if (checkMapReady()) {
          return;
        }
        
        if (checkCount < 20) {
          setTimeout(pollMapReady, 200);
        } else {
          console.warn('⚠️ 지도 준비 타임아웃, 강제 완료');
          setMapReady(true);
          setIsLoading(false);
          setDebugInfo('지도 준비 완료 (타임아웃)');
        }
      };

      setTimeout(pollMapReady, 100);

    } catch (err) {
      console.error('❌ 지도 생성 실패:', err);
      setError(`지도 생성 실패: ${err}`);
      setIsLoading(false);
      setDebugInfo(`지도 생성 실패: ${err}`);
    }
  }, [componentMounted, checkAPIDirectly, center, zoom, showControls, onMapClick, mapReady, createContextMenu, removeContextMenu]);

  // 컴포넌트 마운트 및 API 확인 로직은 기존과 동일
  useEffect(() => {
    console.log('🚀 NaverMap 컴포넌트 마운트됨');
    
    const mountTimer = setTimeout(() => {
      setComponentMounted(true);
    }, 0);

    return () => {
      clearTimeout(mountTimer);
      console.log('🧹 NaverMap 컴포넌트 언마운트');
      
      // 컨텍스트 메뉴 정리
      removeContextMenu();
      
      // 마커 정리
      if (markersRef.current.length > 0) {
        markersRef.current.forEach(marker => marker.setMap(null));
        markersRef.current = [];
      }
    };
  }, [removeContextMenu]);

  useEffect(() => {
    if (!componentMounted) {
      return;
    }

    console.log('🔍 컴포넌트 마운트 완료, API 확인 시작');
    
    let mounted = true;
    let attemptCount = 0;
    const maxAttempts = 100;

    const tryCreateMap = () => {
      if (!mounted || !componentMounted) return;
      
      attemptCount++;
      setDebugInfo(`API 확인 시도 ${attemptCount}/${maxAttempts}`);
      
      if (checkAPIDirectly()) {
        console.log('✅ API 확인 성공, 지도 생성 시작!');
        createMap();
        return;
      }

      if ((window as any).naverMapReady) {
        console.log('✅ 전역 상태 확인 성공, 지도 생성 시작!');
        createMap();
        return;
      }

      if (attemptCount < maxAttempts) {
        setTimeout(tryCreateMap, 500);
      } else {
        console.error('❌ API 확인 최대 재시도 초과');
        setError('네이버 지도 API를 찾을 수 없습니다. 페이지를 새로고침해주세요.');
        setIsLoading(false);
        setDebugInfo('API 확인 타임아웃');
      }
    };

    if (checkAPIDirectly()) {
      console.log('🎯 즉시 API 확인 성공!');
      createMap();
    } else {
      console.log('⏳ API 로드 대기 시작...');
      setTimeout(tryCreateMap, 100);
    }

    const handleNaverReady = () => {
      if (mounted && componentMounted && !mapReady && !mapInstanceRef.current) {
        console.log('🎉 naverMapReady 이벤트 수신! (보조)');
        setTimeout(createMap, 50);
      }
    };

    window.addEventListener('naverMapReady', handleNaverReady);

    return () => {
      mounted = false;
      window.removeEventListener('naverMapReady', handleNaverReady);
    };
  }, [componentMounted, checkAPIDirectly, createMap, mapReady]);

  // 마커 업데이트 로직은 기존과 동일
  useEffect(() => {
    if (!mapReady || !mapInstanceRef.current) {
      console.log('⏸️ 마커 업데이트 대기 (지도 미준비)');
      return;
    }

    console.log(`🏷️ 마커 업데이트 시작: ${markers.length}개`);

    const naverMaps = (window as any).naver.maps;
    
    // 기존 마커 제거
    markersRef.current.forEach(marker => marker.setMap(null));
    markersRef.current = [];

    // 새 마커 추가
    markers.forEach((markerData, index) => {
      try {
        const position = new naverMaps.LatLng(markerData.latitude, markerData.longitude);
        
        const marker = new naverMaps.Marker({
          position: position,
          map: mapInstanceRef.current,
          title: markerData.title,
          icon: {
            content: `
              <div style="
                width: 32px; height: 32px; 
                background: ${markerData.priority === 'urgent' ? '#ef4444' : markerData.priority === 'high' ? '#f97316' : '#10b981'};
                border: 3px solid white; border-radius: 50%; 
                box-shadow: 0 3px 8px rgba(0,0,0,0.4);
                display: flex; align-items: center; justify-content: center;
                color: white; font-size: 16px; cursor: pointer;
                transition: transform 0.2s ease;
              " 
              onmouseover="this.style.transform='scale(1.1)'" 
              onmouseout="this.style.transform='scale(1)'">
                ${markerData.priority === 'urgent' ? '🚨' : markerData.priority === 'high' ? '⚠️' : '📍'}
              </div>
            `,
            size: new naverMaps.Size(32, 32),
            anchor: new naverMaps.Point(16, 16)
          }
        });

        // 클릭 이벤트
        if (onMarkerClick) {
          naverMaps.Event.addListener(marker, 'click', () => {
            console.log('📍 마커 클릭:', markerData.title);
            removeContextMenu(); // 마커 클릭 시도 컨텍스트 메뉴 제거
            onMarkerClick(markerData);
          });
        }

        // 간단한 정보창
        const infoWindow = new naverMaps.InfoWindow({
          content: `
            <div style="padding:8px;max-width:180px;font-size:12px;line-height:1.4;">
              <strong style="color:#333;">${markerData.title}</strong><br>
              <span style="color:#666;">${markerData.description || ''}</span><br>
              <small style="color:#999;">${markerData.road_name || markerData.address || ''}</small>
            </div>
          `,
          backgroundColor: 'white',
          borderColor: '#ddd',
          borderWidth: 1,
          pixelOffset: new naverMaps.Point(0, -5)
        });

        naverMaps.Event.addListener(marker, 'mouseover', () => {
          infoWindow.open(mapInstanceRef.current, marker);
        });

        naverMaps.Event.addListener(marker, 'mouseout', () => {
          infoWindow.close();
        });

        markersRef.current.push(marker);
        console.log(`✅ 마커 ${index + 1} 생성: ${markerData.title}`);
        
      } catch (err) {
        console.error(`❌ 마커 생성 실패 (${markerData.title}):`, err);
      }
    });

    // 지도 범위 조정
    if (markers.length > 0 && mapInstanceRef.current) {
      try {
        if (markers.length === 1) {
          mapInstanceRef.current.setCenter(
            new naverMaps.LatLng(markers[0].latitude, markers[0].longitude)
          );
          mapInstanceRef.current.setZoom(16);
        } else {
          const bounds = new naverMaps.LatLngBounds();
          markers.forEach(marker => {
            bounds.extend(new naverMaps.LatLng(marker.latitude, marker.longitude));
          });
          mapInstanceRef.current.fitBounds(bounds, { top: 50, right: 50, bottom: 50, left: 50 });
        }
        console.log('🎯 지도 범위 조정 완료');
      } catch (err) {
        console.error('❌ 범위 조정 실패:', err);
      }
    }
  }, [markers, onMarkerClick, mapReady, removeContextMenu]);

  // 수동 지도 생성 버튼 핸들러
  const handleManualCreate = () => {
    console.log('🔧 수동 지도 생성 시도');
    setIsLoading(true);
    setError(null);
    setDebugInfo('수동 생성 시도 중...');
    removeContextMenu();
    mapInstanceRef.current = null;
    setMapReady(false);
    createMap();
  };

  return (
    <div className="relative">
      {/* 지도 컨테이너 */}
      <div 
        ref={mapRef} 
        style={{ height }}
        className="w-full rounded-lg overflow-hidden shadow-lg bg-gray-200"
        onContextMenu={(e) => {
          // 브라우저 기본 컨텍스트 메뉴 방지는 네이버 지도에서 처리
          if (!mapReady) {
            e.preventDefault();
          }
        }}
      />
      
      {/* 로딩 오버레이 */}
      {(isLoading || error) && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 rounded-lg z-20">
          {error ? (
            <div className="text-center text-red-700 p-6">
              <div className="text-4xl mb-3">❌</div>
              <p className="font-medium text-lg mb-2">지도 로드 오류</p>
              <p className="text-sm mb-4">{error}</p>
              <div className="space-y-2">
                <button 
                  onClick={() => window.location.reload()} 
                  className="block mx-auto px-4 py-2 bg-red-100 hover:bg-red-200 text-red-800 rounded-lg transition-colors"
                >
                  새로고침
                </button>
                <button 
                  onClick={handleManualCreate}
                  className="block mx-auto px-4 py-2 bg-blue-100 hover:bg-blue-200 text-blue-800 rounded-lg transition-colors text-sm"
                >
                  수동 생성 시도
                </button>
              </div>
            </div>
          ) : (
            <div className="text-center text-gray-500">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-500 mx-auto mb-3"></div>
              <p className="text-lg font-medium">네이버 지도 준비 중...</p>
              <p className="text-sm mt-1">{debugInfo}</p>
            </div>
          )}
        </div>
      )}
      
      {/* 줌 컨트롤 */}
      {mapReady && !isLoading && !error && (
        <div className="absolute top-3 right-3 bg-white rounded-lg shadow-md overflow-hidden z-10">
          <button 
            onClick={() => {
              if (mapInstanceRef.current) {
                const zoom = mapInstanceRef.current.getZoom();
                mapInstanceRef.current.setZoom(zoom + 1);
              }
            }}
            className="block w-10 h-10 bg-white hover:bg-gray-100 border-b border-gray-200 text-lg font-bold transition-colors"
            title="확대"
          >
            +
          </button>
          <button 
            onClick={() => {
              if (mapInstanceRef.current) {
                const zoom = mapInstanceRef.current.getZoom();
                mapInstanceRef.current.setZoom(zoom - 1);
              }
            }}
            className="block w-10 h-10 bg-white hover:bg-gray-100 text-lg font-bold transition-colors"
            title="축소"
          >
            −
          </button>
        </div>
      )}
      
      {/* 사용법 안내 */}
      {mapReady && !isLoading && !error && (
        <div className="absolute top-3 left-3 bg-white bg-opacity-95 rounded-lg px-3 py-2 shadow-md z-10 max-w-xs">
          <p className="text-xs text-gray-600">
            💡 <strong>지도 우클릭</strong>으로 새 마커를 추가할 수 있습니다.
          </p>
        </div>
      )}
      
      {/* 상태 정보 */}
      <div className="absolute bottom-3 left-3 bg-white bg-opacity-95 rounded-lg px-3 py-2 shadow-md z-10">
        <div className="flex items-center space-x-2 text-sm">
          {mapReady ? (
            <>
              <span className="text-green-600 font-medium">✅ 지도 준비</span>
              <span className="text-gray-600">📍 {markers.length}개</span>
            </>
          ) : (
            <>
              <span className="text-orange-600 font-medium">⏳ 로딩중</span>
              <span className="text-gray-600">컨테이너: {mapRef.current ? '✅' : '❌'}</span>
            </>
          )}
        </div>
      </div>
    </div>
  );
};

export default NaverMap;
```

---

### 43. MarkerPopup.tsx

- **경로:** `frontend/src/components/map/MarkerPopup.tsx`
- **크기:** 883 characters
- **타입:** .tsx

```tsx
//frontend/src/components/map/MarkerPopup.tsx
import React from 'react';
import { Marker } from '../../types/marker';

interface MarkerPopupProps {
  marker: Marker;
  onClose: () => void;
}

const MarkerPopup: React.FC<MarkerPopupProps> = ({ marker, onClose }) => {
  return (
    <div className="bg-white rounded-lg shadow-lg p-4 max-w-sm">
      <div className="flex justify-between items-start mb-2">
        <h3 className="font-semibold text-gray-900">{marker.title}</h3>
        <button 
          onClick={onClose}
          className="text-gray-400 hover:text-gray-600"
        >
          ✕
        </button>
      </div>
      <p className="text-sm text-gray-600 mb-2">{marker.description}</p>
      <div className="text-xs text-gray-500">
        📍 {marker.address || `${marker.latitude}, ${marker.longitude}`}
      </div>
    </div>
  );
};

export default MarkerPopup;

```

---

### 44. MarkerAddPopup.tsx

- **경로:** `frontend/src/components/map/MarkerAddPopup.tsx`
- **크기:** 16,309 characters
- **타입:** .tsx

```tsx
// frontend/src/components/map/MarkerAddPopup.tsx (동영상 업로드 포함)
import React, { useState, useEffect, useRef } from 'react';
import { MarkerCreate, IssueType, MarkerPriority } from '../../types/marker';
import { ISSUE_TYPE_LABELS, MARKER_PRIORITY_LABELS } from '../../utils/constants';
import { formatFileSize } from '../../utils/helpers';

interface MarkerAddPopupProps {
  isOpen: boolean;
  position: { lat: number; lng: number } | null;
  onSubmit: (marker: MarkerCreate, videoFile?: File) => Promise<void>;
  onClose: () => void;
  loading?: boolean;
}

const MarkerAddPopup: React.FC<MarkerAddPopupProps> = ({
  isOpen,
  position,
  onSubmit,
  onClose,
  loading = false
}) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [formData, setFormData] = useState<Omit<MarkerCreate, 'latitude' | 'longitude'>>({
    title: '',
    description: '',
    address: '',
    road_name: '',
    issue_type: IssueType.CRACK,
    priority: MarkerPriority.NORMAL,
    assigned_to: '',
    created_by: '김관리자'
  });

  const [selectedVideo, setSelectedVideo] = useState<File | null>(null);
  const [videoPreview, setVideoPreview] = useState<string | null>(null);
  const [addressLoading, setAddressLoading] = useState(false);
  const [addressError, setAddressError] = useState<string | null>(null);

  // 허용되는 비디오 형식
  const allowedVideoTypes = ['video/mp4', 'video/mov', 'video/avi', 'video/mkv'];
  const maxVideoSize = 100 * 1024 * 1024; // 100MB

  // 좌표로부터 주소 검색 (역지오코딩)
  const reverseGeocode = async (lat: number, lng: number) => {
    if (!(window as any).naver?.maps?.Service) {
      console.warn('네이버 지도 Geocoding 서비스를 사용할 수 없습니다.');
      return;
    }

    setAddressLoading(true);
    setAddressError(null);

    try {
      const coords = new (window as any).naver.maps.LatLng(lat, lng);
      
      (window as any).naver.maps.Service.reverseGeocode({
        coords: coords,
        orders: [
          (window as any).naver.maps.Service.OrderType.ADDR,
          (window as any).naver.maps.Service.OrderType.ROAD_ADDR
        ].join(',')
      }, (status: any, response: any) => {
        setAddressLoading(false);
        
        if (status === (window as any).naver.maps.Service.Status.ERROR) {
          setAddressError('주소를 찾을 수 없습니다.');
          return;
        }

        if (response.v2 && response.v2.results && response.v2.results.length > 0) {
          const result = response.v2.results[0];
          const roadAddr = result.region?.area1?.name + ' ' + 
                          result.region?.area2?.name + ' ' + 
                          (result.land?.name || '');
          
          setFormData(prev => ({
            ...prev,
            address: result.region?.area1?.name + ' ' + result.region?.area2?.name,
            road_name: roadAddr.trim()
          }));
        }
      });
    } catch (error) {
      console.error('역지오코딩 오류:', error);
      setAddressLoading(false);
      setAddressError('주소 검색 중 오류가 발생했습니다.');
    }
  };

  // 비디오 파일 선택 핸들러
  const handleVideoSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // 파일 타입 검증
    if (!allowedVideoTypes.includes(file.type)) {
      alert('지원하지 않는 비디오 형식입니다.\n지원 형식: MP4, MOV, AVI, MKV');
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    // 파일 크기 검증
    if (file.size > maxVideoSize) {
      alert(`파일 크기가 너무 큽니다.\n최대 크기: ${formatFileSize(maxVideoSize)}`);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    setSelectedVideo(file);

    // 비디오 미리보기 생성
    const url = URL.createObjectURL(file);
    setVideoPreview(url);
  };

  // 비디오 제거 핸들러
  const handleVideoRemove = () => {
    setSelectedVideo(null);
    if (videoPreview) {
      URL.revokeObjectURL(videoPreview);
      setVideoPreview(null);
    }
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  // 팝업이 열릴 때마다 폼 초기화
  useEffect(() => {
    if (isOpen && position) {
      // 폼 초기화
      setFormData({
        title: '',
        description: '',
        address: '',
        road_name: '',
        issue_type: IssueType.CRACK,
        priority: MarkerPriority.NORMAL,
        assigned_to: '',
        created_by: '김관리자'
      });
      
      // 비디오 관련 상태 초기화
      setSelectedVideo(null);
      if (videoPreview) {
        URL.revokeObjectURL(videoPreview);
        setVideoPreview(null);
      }
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      
      // 주소 검색
      reverseGeocode(position.lat, position.lng);
    }
  }, [isOpen, position]);

  // 컴포넌트 언마운트 시 미리보기 URL 정리
  useEffect(() => {
    return () => {
      if (videoPreview) {
        URL.revokeObjectURL(videoPreview);
      }
    };
  }, [videoPreview]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!position) return;

    const markerData: MarkerCreate = {
      ...formData,
      latitude: position.lat,
      longitude: position.lng
    };

    try {
      await onSubmit(markerData, selectedVideo || undefined);
      onClose();
    } catch (error) {
      console.error('마커 생성 오류:', error);
    }
  };

  const handleInputChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  if (!isOpen || !position) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* 백드롭 */}
      <div 
        className="absolute inset-0 bg-black bg-opacity-50"
        onClick={onClose}
      />
      
      {/* 팝업 */}
      <div className="relative bg-white rounded-xl shadow-2xl w-full max-w-2xl mx-4 max-h-[90vh] overflow-y-auto">
        {/* 헤더 */}
        <div className="bg-gradient-to-r from-primary-500 to-secondary-500 text-white p-4 rounded-t-xl">
          <div className="flex items-center justify-between">
            <div>
              <h2 className="text-lg font-semibold">📍 새 마커 추가</h2>
              <p className="text-sm opacity-90">
                위치: {position.lat.toFixed(6)}, {position.lng.toFixed(6)}
              </p>
            </div>
            <button
              onClick={onClose}
              className="p-1 hover:bg-white hover:bg-opacity-20 rounded-full transition-colors"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>

        {/* 폼 */}
        <form onSubmit={handleSubmit} className="p-6 space-y-6">
          {/* 기본 정보 섹션 */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium text-gray-900 border-b border-gray-200 pb-2">
              📋 기본 정보
            </h3>
            
            {/* 제목 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                제목 <span className="text-red-500">*</span>
              </label>
              <input
                type="text"
                required
                value={formData.title}
                onChange={(e) => handleInputChange('title', e.target.value)}
                placeholder="예: 서울로 교차점 방사 균열"
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* 이슈 유형 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">이슈 유형</label>
                <select
                  value={formData.issue_type}
                  onChange={(e) => handleInputChange('issue_type', e.target.value as IssueType)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                >
                  {Object.entries(ISSUE_TYPE_LABELS).map(([key, label]) => (
                    <option key={key} value={key}>{label}</option>
                  ))}
                </select>
              </div>

              {/* 우선순위 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">우선순위</label>
                <select
                  value={formData.priority}
                  onChange={(e) => handleInputChange('priority', e.target.value as MarkerPriority)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                >
                  {Object.entries(MARKER_PRIORITY_LABELS).map(([key, label]) => (
                    <option key={key} value={key}>{label}</option>
                  ))}
                </select>
              </div>
            </div>

            {/* 설명 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">설명</label>
              <textarea
                value={formData.description}
                onChange={(e) => handleInputChange('description', e.target.value)}
                rows={3}
                placeholder="상세 설명을 입력하세요"
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500 resize-none"
              />
            </div>
          </div>

          {/* 위치 정보 섹션 */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium text-gray-900 border-b border-gray-200 pb-2">
              📍 위치 정보
            </h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* 주소 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  주소
                  {addressLoading && (
                    <span className="ml-2 text-xs text-blue-600">
                      <span className="inline-block animate-spin mr-1">🔄</span>
                      검색 중...
                    </span>
                  )}
                </label>
                {addressError && (
                  <p className="text-xs text-red-600 mb-1">{addressError}</p>
                )}
                <input
                  type="text"
                  value={formData.address}
                  onChange={(e) => handleInputChange('address', e.target.value)}
                  placeholder="주소가 자동으로 검색됩니다"
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                />
              </div>

              {/* 도로명 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">도로명</label>
                <input
                  type="text"
                  value={formData.road_name}
                  onChange={(e) => handleInputChange('road_name', e.target.value)}
                  placeholder="도로명이 자동으로 검색됩니다"
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                />
              </div>
            </div>

            {/* 담당자 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">담당자</label>
              <input
                type="text"
                value={formData.assigned_to}
                onChange={(e) => handleInputChange('assigned_to', e.target.value)}
                placeholder="담당자명 (선택사항)"
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
              />
            </div>
          </div>

          {/* 비디오 업로드 섹션 */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium text-gray-900 border-b border-gray-200 pb-2">
              🎥 비디오 업로드 (선택사항)
            </h3>
            
            {!selectedVideo ? (
              <div>
                <div 
                  className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-primary-400 transition-colors cursor-pointer"
                  onClick={() => fileInputRef.current?.click()}
                >
                  <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleVideoSelect}
                    accept="video/mp4,video/mov,video/avi,video/mkv"
                    className="hidden"
                  />
                  <div className="text-4xl mb-3">🎥</div>
                  <p className="text-lg font-medium text-gray-700 mb-2">비디오 파일 선택</p>
                  <p className="text-sm text-gray-500 mb-2">클릭하여 파일을 선택하세요</p>
                  <p className="text-xs text-gray-400">
                    지원 형식: MP4, MOV, AVI, MKV<br/>
                    최대 크기: {formatFileSize(maxVideoSize)}
                  </p>
                </div>
              </div>
            ) : (
              <div className="space-y-3">
                {/* 선택된 파일 정보 */}
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <div className="flex items-start justify-between">
                    <div className="flex-1">
                      <h4 className="font-medium text-blue-900 mb-1">선택된 비디오</h4>
                      <p className="text-sm text-blue-700 mb-1">{selectedVideo.name}</p>
                      <p className="text-xs text-blue-600">
                        크기: {formatFileSize(selectedVideo.size)} | 
                        형식: {selectedVideo.type}
                      </p>
                    </div>
                    <button
                      type="button"
                      onClick={handleVideoRemove}
                      className="text-red-500 hover:text-red-700 p-1"
                      title="비디오 제거"
                    >
                      🗑️
                    </button>
                  </div>
                </div>

                {/* 비디오 미리보기 */}
                {videoPreview && (
                  <div className="bg-black rounded-lg overflow-hidden">
                    <video
                      src={videoPreview}
                      controls
                      className="w-full max-h-48"
                      preload="metadata"
                    >
                      브라우저에서 비디오를 지원하지 않습니다.
                    </video>
                  </div>
                )}

                {/* 다른 비디오 선택 버튼 */}
                <button
                  type="button"
                  onClick={() => fileInputRef.current?.click()}
                  className="w-full py-2 px-4 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors text-sm"
                >
                  다른 비디오 선택
                </button>
              </div>
            )}
          </div>

          {/* 버튼 */}
          <div className="flex space-x-3 pt-4 border-t border-gray-200">
            <button
              type="button"
              onClick={onClose}
              disabled={loading}
              className="flex-1 px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50"
            >
              취소
            </button>
            <button
              type="submit"
              disabled={loading || !formData.title.trim()}
              className="flex-1 px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600 transition-colors disabled:opacity-50 flex items-center justify-center"
            >
              {loading ? (
                <>
                  <span className="inline-block animate-spin mr-2">🔄</span>
                  {selectedVideo ? '마커 생성 및 업로드 중...' : '마커 생성 중...'}
                </>
              ) : (
                <>
                  {selectedVideo ? '📍🎥 마커 생성 및 업로드' : '📍 마커 생성'}
                </>
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default MarkerAddPopup;
```

---

### 45. Modal.tsx

- **경로:** `frontend/src/components/common/Modal.tsx`
- **크기:** 2,214 characters
- **타입:** .tsx

```tsx
// frontend/src/components/common/Modal.tsx
import React, { useEffect } from 'react';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl';
}

const Modal: React.FC<ModalProps> = ({ 
  isOpen, 
  onClose, 
  title, 
  children, 
  size = 'md' 
}) => {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  const sizeClasses = {
    sm: 'max-w-md',
    md: 'max-w-lg',
    lg: 'max-w-4xl',
    xl: 'max-w-6xl'
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black bg-opacity-50"
        onClick={onClose}
      />
      
      {/* Modal */}
      <div className={`
        relative bg-white rounded-lg shadow-xl w-full mx-4
        ${sizeClasses[size]}
        max-h-[90vh] overflow-hidden
        animate-slideUp
      `}>
        {/* Header */}
        <div className="bg-gradient-to-r from-primary-500 to-secondary-500 text-white px-6 py-4">
          <div className="flex items-center justify-between">
            <h2 className="text-xl font-semibold">{title}</h2>
            <button
              onClick={onClose}
              className="p-1 hover:bg-white hover:bg-opacity-20 rounded-full transition-colors"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
        
        {/* Body */}
        <div className="p-6 overflow-y-auto max-h-[calc(90vh-80px)]">
          {children}
        </div>
      </div>
    </div>
  );
};

export default Modal;
```

---

### 46. Sidebar.tsx

- **경로:** `frontend/src/components/common/Sidebar.tsx`
- **크기:** 2,736 characters
- **타입:** .tsx

```tsx
// frontend/src/components/common/Sidebar.tsx
import React from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

interface SidebarProps {
  isOpen: boolean;
  onClose: () => void;
}

interface MenuItem {
  id: string;
  label: string;
  icon: string;
  path: string;
}

const menuItems: MenuItem[] = [
  { id: 'dashboard', label: '대시보드', icon: '📊', path: '/' },
  { id: 'markers', label: '마커 관리', icon: '📍', path: '/markers' },
  { id: 'analytics', label: '통계 분석', icon: '📈', path: '/analytics' },
  { id: 'settings', label: '설정', icon: '⚙️', path: '/settings' },
];

const Sidebar: React.FC<SidebarProps> = ({ isOpen, onClose }) => {
  const location = useLocation();
  const navigate = useNavigate();

  const handleNavigation = (path: string) => {
    navigate(path);
    if (window.innerWidth < 768) {
      onClose();
    }
  };

  return (
    <>
      {/* Overlay for mobile */}
      {isOpen && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40 md:hidden"
          onClick={onClose}
        />
      )}
      
      {/* Sidebar */}
      <aside className={`
        fixed top-16 left-0 h-full w-64 bg-white shadow-lg z-40 transform transition-transform duration-300 ease-in-out
        ${isOpen ? 'translate-x-0' : '-translate-x-full'}
      `}>
        <nav className="mt-4">
          <ul className="space-y-1">
            {menuItems.map((item) => (
              <li key={item.id}>
                <button
                  onClick={() => handleNavigation(item.path)}
                  className={`
                    w-full flex items-center space-x-3 px-6 py-3 text-left transition-colors duration-200
                    border-l-4 border-transparent hover:bg-gray-50 hover:border-primary-500
                    ${location.pathname === item.path 
                      ? 'bg-primary-50 border-primary-500 text-primary-700 font-medium' 
                      : 'text-gray-700'
                    }
                  `}
                >
                  <span className="text-xl">{item.icon}</span>
                  <span className="font-medium">{item.label}</span>
                </button>
              </li>
            ))}
          </ul>
        </nav>
        
        <div className="absolute bottom-4 left-4 right-4">
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="text-sm font-medium text-gray-900 mb-2">시스템 상태</h4>
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 bg-green-400 rounded-full"></div>
              <span className="text-sm text-gray-600">정상 운영 중</span>
            </div>
          </div>
        </div>
      </aside>
    </>
  );
};

export default Sidebar;
```

---

### 47. Header.tsx

- **경로:** `frontend/src/components/common/Header.tsx`
- **크기:** 2,066 characters
- **타입:** .tsx

```tsx
// frontend/src/components/common/Header.tsx
import React from 'react';

interface HeaderProps {
  onToggleSidebar: () => void;
}

const Header: React.FC<HeaderProps> = ({ onToggleSidebar }) => {
  return (
    <header className="bg-gradient-to-r from-primary-500 to-secondary-500 text-white shadow-lg fixed top-0 left-0 right-0 z-50 h-16">
      <div className="flex items-center justify-between h-full px-6">
        <div className="flex items-center space-x-4">
          <button
            onClick={onToggleSidebar}
            className="p-2 rounded-lg hover:bg-white hover:bg-opacity-20 transition-colors"
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
            </svg>
          </button>
          <div className="flex items-center space-x-2">
            <span className="text-2xl">🛣️</span>
            <h1 className="text-xl font-bold">도로관리 시스템</h1>
          </div>
        </div>
        
        <div className="flex items-center space-x-4">
          <button className="relative p-2 rounded-lg hover:bg-white hover:bg-opacity-20 transition-colors">
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-5 5-5-5h5v-12a4 4 0 00-8 0v12" />
            </svg>
            <span className="absolute -top-1 -right-1 bg-red-500 text-xs rounded-full h-5 w-5 flex items-center justify-center">
              3
            </span>
          </button>
          
          <div className="flex items-center space-x-2">
            <div className="w-8 h-8 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
              <span className="text-sm font-medium">김</span>
            </div>
            <span className="text-sm font-medium">김관리자</span>
          </div>
        </div>
      </div>
    </header>
  );
};

export default Header;
```

---

### 48. LoadingSpinner.tsx

- **경로:** `frontend/src/components/common/LoadingSpinner.tsx`
- **크기:** 706 characters
- **타입:** .tsx

```tsx
// frontend/src/components/common/LoadingSpinner.tsx
import React from 'react';

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  text?: string;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  size = 'md', 
  text = '로딩 중...' 
}) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12'
  };

  return (
    <div className="flex flex-col items-center justify-center space-y-2">
      <div className={`
        ${sizeClasses[size]} 
        border-4 border-gray-200 border-t-primary-500 
        rounded-full animate-spin
      `} />
      {text && <p className="text-gray-600 text-sm">{text}</p>}
    </div>
  );
};

export default LoadingSpinner;
```

---

### 49. MarkerList.tsx

- **경로:** `frontend/src/components/markers/MarkerList.tsx`
- **크기:** 2,035 characters
- **타입:** .tsx

```tsx
import React from 'react';
import { Marker } from '../../types/marker';
import { MARKER_STATUS_COLORS, MARKER_PRIORITY_COLORS } from '../../utils/constants';
import { formatDate, getStatusBadgeClass } from '../../utils/helpers';

interface MarkerListProps {
  markers: Marker[];
  onMarkerClick: (marker: Marker) => void;
  loading?: boolean;
}

const MarkerList: React.FC<MarkerListProps> = ({ markers, onMarkerClick, loading }) => {
  if (loading) {
    return (
      <div className="flex justify-center py-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary-500"></div>
      </div>
    );
  }

  if (markers.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        <div className="text-4xl mb-4">📍</div>
        <p>등록된 마커가 없습니다</p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {markers.map((marker) => (
        <div
          key={marker.id}
          onClick={() => onMarkerClick(marker)}
          className="bg-white border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow cursor-pointer"
        >
          <div className="flex justify-between items-start mb-2">
            <h3 className="font-semibold text-gray-900">{marker.title}</h3>
            <div className="flex space-x-2">
              <span className={getStatusBadgeClass(marker.status, MARKER_STATUS_COLORS)}>
                {marker.status}
              </span>
              <span className={getStatusBadgeClass(marker.priority, MARKER_PRIORITY_COLORS)}>
                {marker.priority}
              </span>
            </div>
          </div>
          
          <p className="text-sm text-gray-600 mb-2">{marker.description}</p>
          
          <div className="flex justify-between items-center text-xs text-gray-500">
            <span>�� {marker.road_name || marker.address}</span>
            <span>{formatDate(marker.created_at)}</span>
          </div>
        </div>
      ))}
    </div>
  );
};

export default MarkerList;

```

---

### 50. MarkerDetail.tsx

- **경로:** `frontend/src/components/markers/MarkerDetail.tsx`
- **크기:** 10,557 characters
- **타입:** .tsx

```tsx
// frontend/src/components/markers/MarkerDetail.tsx (수정된 버전)
import React, { useState } from 'react';
import { Marker, MarkerStatus, MarkerPriority, MarkerUpdate } from '../../types/marker';
import { MARKER_STATUS_LABELS, MARKER_PRIORITY_LABELS, MARKER_STATUS_COLORS, MARKER_PRIORITY_COLORS } from '../../utils/constants';
import { formatDate, getStatusBadgeClass } from '../../utils/helpers';

interface MarkerDetailProps {
  marker: Marker;
  onEdit: (updates: MarkerUpdate) => Promise<void>; // Promise<void> 명시
  onDelete: () => Promise<void>; // Promise<void> 명시
}

const MarkerDetail: React.FC<MarkerDetailProps> = ({ marker, onEdit, onDelete }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editData, setEditData] = useState<MarkerUpdate>({
    title: marker.title,
    description: marker.description,
    status: marker.status,
    priority: marker.priority,
    assigned_to: marker.assigned_to
  });
  const [isLoading, setIsLoading] = useState(false);

  const handleEditSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      setIsLoading(true);
      await onEdit(editData);
      setIsEditing(false);
    } catch (error) {
      console.error('수정 중 오류:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteClick = async () => {
    if (!window.confirm('이 마커를 삭제하시겠습니까?')) return;
    
    try {
      setIsLoading(true);
      await onDelete();
    } catch (error) {
      console.error('삭제 중 오류:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleEditCancel = () => {
    setEditData({
      title: marker.title,
      description: marker.description,
      status: marker.status,
      priority: marker.priority,
      assigned_to: marker.assigned_to
    });
    setIsEditing(false);
  };

  if (isEditing) {
    return (
      <div className="space-y-4">
        <h3 className="text-lg font-semibold text-gray-900 border-b border-gray-200 pb-2">
          ✏️ 마커 수정
        </h3>
        
        <form onSubmit={handleEditSubmit} className="space-y-4">
          {/* 제목 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">제목</label>
            <input
              type="text"
              value={editData.title || ''}
              onChange={(e) => setEditData(prev => ({ ...prev, title: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
              required
            />
          </div>

          {/* 설명 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">설명</label>
            <textarea
              value={editData.description || ''}
              onChange={(e) => setEditData(prev => ({ ...prev, description: e.target.value }))}
              rows={3}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            />
          </div>

          {/* 상태 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">상태</label>
            <select
              value={editData.status || ''}
              onChange={(e) => setEditData(prev => ({ ...prev, status: e.target.value as MarkerStatus }))}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            >
              {Object.entries(MARKER_STATUS_LABELS).map(([key, label]) => (
                <option key={key} value={key}>{label}</option>
              ))}
            </select>
          </div>

          {/* 우선순위 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">우선순위</label>
            <select
              value={editData.priority || ''}
              onChange={(e) => setEditData(prev => ({ ...prev, priority: e.target.value as MarkerPriority }))}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            >
              {Object.entries(MARKER_PRIORITY_LABELS).map(([key, label]) => (
                <option key={key} value={key}>{label}</option>
              ))}
            </select>
          </div>

          {/* 담당자 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">담당자</label>
            <input
              type="text"
              value={editData.assigned_to || ''}
              onChange={(e) => setEditData(prev => ({ ...prev, assigned_to: e.target.value }))}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
              placeholder="담당자명 (선택사항)"
            />
          </div>

          {/* 버튼 */}
          <div className="flex justify-end space-x-3 pt-4 border-t border-gray-200">
            <button
              type="button"
              onClick={handleEditCancel}
              disabled={isLoading}
              className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50"
            >
              취소
            </button>
            <button
              type="submit"
              disabled={isLoading || !editData.title?.trim()}
              className="px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600 transition-colors disabled:opacity-50 flex items-center space-x-2"
            >
              {isLoading ? (
                <>
                  <span className="animate-spin">🔄</span>
                  <span>저장 중...</span>
                </>
              ) : (
                <>
                  <span>✅</span>
                  <span>저장</span>
                </>
              )}
            </button>
          </div>
        </form>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* 기본 정보 */}
      <div>
        <div className="flex items-center justify-between border-b border-gray-200 pb-2 mb-4">
          <h3 className="text-lg font-semibold text-gray-900">📋 기본 정보</h3>
          <div className="flex space-x-2">
            <button
              onClick={() => setIsEditing(true)}
              disabled={isLoading}
              className="text-blue-600 hover:text-blue-700 p-1 disabled:opacity-50"
              title="수정"
            >
              ✏️
            </button>
          </div>
        </div>
        
        <div className="space-y-4">
          <div>
            <h4 className="font-semibold text-gray-900 text-lg mb-2">{marker.title}</h4>
            <p className="text-gray-600 leading-relaxed">{marker.description || '설명 없음'}</p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">상태</label>
              <span className={getStatusBadgeClass(marker.status, MARKER_STATUS_COLORS)}>
                {MARKER_STATUS_LABELS[marker.status]}
              </span>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">우선순위</label>
              <span className={getStatusBadgeClass(marker.priority, MARKER_PRIORITY_COLORS)}>
                {MARKER_PRIORITY_LABELS[marker.priority]}
              </span>
            </div>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">담당자</label>
              <p className="text-sm text-gray-900">{marker.assigned_to || '미배정'}</p>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">생성자</label>
              <p className="text-sm text-gray-900">{marker.created_by}</p>
            </div>
          </div>
        </div>
      </div>

      {/* 위치 정보 */}
      <div>
        <h4 className="font-semibold text-gray-900 border-b border-gray-200 pb-2 mb-4">📍 위치 정보</h4>
        <div className="space-y-2">
          <div>
            <label className="block text-sm font-medium text-gray-700">주소</label>
            <p className="text-sm text-gray-900">{marker.address || '주소 없음'}</p>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">도로명</label>
            <p className="text-sm text-gray-900">{marker.road_name || '도로명 없음'}</p>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">좌표</label>
            <p className="text-sm text-gray-900 font-mono">
              {marker.latitude.toFixed(6)}, {marker.longitude.toFixed(6)}
            </p>
          </div>
        </div>
      </div>

      {/* 시간 정보 */}
      <div>
        <h4 className="font-semibold text-gray-900 border-b border-gray-200 pb-2 mb-4">🕐 시간 정보</h4>
        <div className="space-y-2">
          <div>
            <label className="block text-sm font-medium text-gray-700">생성일</label>
            <p className="text-sm text-gray-900">{formatDate(marker.created_at)}</p>
          </div>
          {marker.updated_at && (
            <div>
              <label className="block text-sm font-medium text-gray-700">수정일</label>
              <p className="text-sm text-gray-900">{formatDate(marker.updated_at)}</p>
            </div>
          )}
        </div>
      </div>

      {/* 액션 버튼 */}
      <div className="flex justify-end space-x-3 pt-4 border-t border-gray-200">
        <button
          onClick={() => setIsEditing(true)}
          disabled={isLoading}
          className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 flex items-center space-x-2"
        >
          <span>✏️</span>
          <span>수정</span>
        </button>
        <button
          onClick={handleDeleteClick}
          disabled={isLoading}
          className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors disabled:opacity-50 flex items-center space-x-2"
        >
          {isLoading ? (
            <>
              <span className="animate-spin">🔄</span>
              <span>삭제 중...</span>
            </>
          ) : (
            <>
              <span>🗑️</span>
              <span>삭제</span>
            </>
          )}
        </button>
      </div>
    </div>
  );
};

export default MarkerDetail;
```

---

### 51. MarkerForm.tsx

- **경로:** `frontend/src/components/markers/MarkerForm.tsx`
- **크기:** 3,384 characters
- **타입:** .tsx

```tsx
import React, { useState } from 'react';
import { MarkerCreate, IssueType, MarkerPriority } from '../../types/marker';

interface MarkerFormProps {
  onSubmit: (marker: MarkerCreate) => void;
  onCancel: () => void;
  initialData?: Partial<MarkerCreate>;
}

const MarkerForm: React.FC<MarkerFormProps> = ({ onSubmit, onCancel, initialData }) => {
  const [formData, setFormData] = useState<MarkerCreate>({
    title: initialData?.title || '',
    description: initialData?.description || '',
    latitude: initialData?.latitude || 37.5665,
    longitude: initialData?.longitude || 126.9780,
    address: initialData?.address || '',
    road_name: initialData?.road_name || '',
    issue_type: initialData?.issue_type || IssueType.CRACK,
    priority: initialData?.priority || MarkerPriority.NORMAL,
    assigned_to: initialData?.assigned_to || '',
    created_by: '김관리자' // 임시값
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSubmit(formData);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">제목</label>
        <input
          type="text"
          required
          value={formData.title}
          onChange={(e) => setFormData({ ...formData, title: e.target.value })}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-primary-500 focus:border-primary-500"
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">설명</label>
        <textarea
          value={formData.description}
          onChange={(e) => setFormData({ ...formData, description: e.target.value })}
          rows={3}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-primary-500 focus:border-primary-500"
        />
      </div>
      
      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">위도</label>
          <input
            type="number"
            step="any"
            required
            value={formData.latitude}
            onChange={(e) => setFormData({ ...formData, latitude: parseFloat(e.target.value) })}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-primary-500 focus:border-primary-500"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">경도</label>
          <input
            type="number"
            step="any"
            required
            value={formData.longitude}
            onChange={(e) => setFormData({ ...formData, longitude: parseFloat(e.target.value) })}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-primary-500 focus:border-primary-500"
          />
        </div>
      </div>
      
      <div className="flex justify-end space-x-3">
        <button
          type="button"
          onClick={onCancel}
          className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
        >
          취소
        </button>
        <button
          type="submit"
          className="px-4 py-2 bg-primary-500 text-white rounded-lg hover:bg-primary-600"
        >
          저장
        </button>
      </div>
    </form>
  );
};

export default MarkerForm;

```

---

### 52. useVideo.ts

- **경로:** `frontend/src/hooks/useVideo.ts`
- **크기:** 1,738 characters
- **타입:** .ts

```typescript
// frontend/src/hooks/useVideo.ts
import { useState, useEffect } from 'react';
import { Video, VideoUpload } from '../types/video';
import { videoService } from '../services/videoService';

export const useVideos = (markerId: number | null) => {
  const [videos, setVideos] = useState<Video[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchVideos = async (id: number) => {
    try {
      setLoading(true);
      setError(null);
      const data = await videoService.getMarkerVideos(id);
      setVideos(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '비디오 조회 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const uploadVideo = async (id: number, upload: VideoUpload): Promise<Video | null> => {
    try {
      const newVideo = await videoService.uploadVideo(id, upload);
      setVideos(prev => [newVideo, ...prev]);
      return newVideo;
    } catch (err) {
      setError(err instanceof Error ? err.message : '비디오 업로드 중 오류가 발생했습니다.');
      return null;
    }
  };

  const deleteVideo = async (id: number): Promise<boolean> => {
    try {
      await videoService.deleteVideo(id);
      setVideos(prev => prev.filter(video => video.id !== id));
      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : '비디오 삭제 중 오류가 발생했습니다.');
      return false;
    }
  };

  useEffect(() => {
    if (markerId) {
      fetchVideos(markerId);
    }
  }, [markerId]);

  return {
    videos,
    loading,
    error,
    refetch: () => markerId && fetchVideos(markerId),
    uploadVideo: (upload: VideoUpload) => markerId && uploadVideo(markerId, upload),
    deleteVideo
  };
};
```

---

### 53. useMarkers.ts

- **경로:** `frontend/src/hooks/useMarkers.ts`
- **크기:** 2,853 characters
- **타입:** .ts

```typescript
// frontend/src/hooks/useMarkers.ts
import { useState, useEffect } from 'react';
import { Marker, MarkerCreate, MarkerUpdate } from '../types/marker';
import { markerService, MarkerQueryParams } from '../services/markerService';

export const useMarkers = (params: MarkerQueryParams = {}) => {
  const [markers, setMarkers] = useState<Marker[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchMarkers = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await markerService.getMarkers(params);
      setMarkers(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '마커 조회 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const createMarker = async (marker: MarkerCreate): Promise<Marker | null> => {
    try {
      const newMarker = await markerService.createMarker(marker);
      setMarkers(prev => [newMarker, ...prev]);
      return newMarker;
    } catch (err) {
      setError(err instanceof Error ? err.message : '마커 생성 중 오류가 발생했습니다.');
      return null;
    }
  };

  const updateMarker = async (id: number, updates: MarkerUpdate): Promise<Marker | null> => {
    try {
      const updatedMarker = await markerService.updateMarker(id, updates);
      setMarkers(prev => prev.map(marker => 
        marker.id === id ? updatedMarker : marker
      ));
      return updatedMarker;
    } catch (err) {
      setError(err instanceof Error ? err.message : '마커 수정 중 오류가 발생했습니다.');
      return null;
    }
  };

  const deleteMarker = async (id: number): Promise<boolean> => {
    try {
      await markerService.deleteMarker(id);
      setMarkers(prev => prev.filter(marker => marker.id !== id));
      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : '마커 삭제 중 오류가 발생했습니다.');
      return false;
    }
  };

  useEffect(() => {
    fetchMarkers();
  }, [JSON.stringify(params)]);

  return {
    markers,
    loading,
    error,
    refetch: fetchMarkers,
    createMarker,
    updateMarker,
    deleteMarker
  };
};

export const useMarker = (id: number | null) => {
  const [marker, setMarker] = useState<Marker | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchMarker = async (markerId: number) => {
    try {
      setLoading(true);
      setError(null);
      const data = await markerService.getMarker(markerId);
      setMarker(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '마커 조회 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (id) {
      fetchMarker(id);
    }
  }, [id]);

  return {
    marker,
    loading,
    error,
    refetch: () => id && fetchMarker(id)
  };
};

```

---

### 54. useAIAnalysis.ts

- **경로:** `frontend/src/hooks/useAIAnalysis.ts`
- **크기:** 2,146 characters
- **타입:** .ts

```typescript
// frontend/src/hooks/useAIAnalysis.ts
import { useState, useEffect } from 'react';
import { Analysis } from '../types/analysis';
import { analysisService } from '../services/analysisService';

export const useAnalyses = (videoId: number | null) => {
  const [analyses, setAnalyses] = useState<Analysis[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchAnalyses = async (id: number) => {
    try {
      setLoading(true);
      setError(null);
      const data = await analysisService.getVideoAnalyses(id);
      setAnalyses(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '분석 결과 조회 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const startAnalysis = async (id: number): Promise<Analysis | null> => {
    try {
      const newAnalysis = await analysisService.startAnalysis(id);
      setAnalyses(prev => [newAnalysis, ...prev]);
      return newAnalysis;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'AI 분석 시작 중 오류가 발생했습니다.');
      return null;
    }
  };

  useEffect(() => {
    if (videoId) {
      fetchAnalyses(videoId);
    }
  }, [videoId]);

  return {
    analyses,
    loading,
    error,
    refetch: () => videoId && fetchAnalyses(videoId),
    startAnalysis: () => videoId && startAnalysis(videoId)
  };
};

export const useAnalysis = (id: number | null) => {
  const [analysis, setAnalysis] = useState<Analysis | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchAnalysis = async (analysisId: number) => {
    try {
      setLoading(true);
      setError(null);
      const data = await analysisService.getAnalysis(analysisId);
      setAnalysis(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : '분석 결과 조회 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (id) {
      fetchAnalysis(id);
    }
  }, [id]);

  return {
    analysis,
    loading,
    error,
    refetch: () => id && fetchAnalysis(id)
  };
};
```

---

### 55. AnalyticsPage.tsx

- **경로:** `frontend/src/pages/AnalyticsPage.tsx`
- **크기:** 728 characters
- **타입:** .tsx

```tsx
// frontend/src/pages/AnalyticsPage.tsx
import React from 'react';

const AnalyticsPage: React.FC = () => {
  return (
    <div className="space-y-6">
      <div className="bg-white rounded-lg shadow-sm p-6">
        <h1 className="text-2xl font-bold text-gray-900 mb-2">통계 분석</h1>
        <p className="text-gray-600">도로 유지보수 데이터를 분석하여 인사이트를 제공합니다</p>
      </div>
      
      <div className="bg-white rounded-lg shadow-sm p-6">
        <div className="text-center text-gray-500">
          <div className="text-4xl mb-4">📈</div>
          <p className="text-lg font-medium">통계 분석 페이지</p>
          <p className="text-sm">차트와 분석 데이터가 여기에 표시됩니다</p>
        </div>
      </div>
    </div>
  );
};

export default AnalyticsPage;

```

---

### 56. MarkersPage.tsx

- **경로:** `frontend/src/pages/MarkersPage.tsx`
- **크기:** 19,525 characters
- **타입:** .tsx

```tsx
import React, { useState, useEffect } from 'react';
import { useMarkers } from '../hooks/useMarkers';
import { useVideos } from '../hooks/useVideo';
import { useAnalyses } from '../hooks/useAIAnalysis';
import { Marker, MarkerStatus, MarkerPriority, IssueType } from '../types/marker';
import { Video } from '../types/video';
import { Analysis } from '../types/analysis';
import LoadingSpinner from '../components/common/LoadingSpinner';
import Modal from '../components/common/Modal';
import MarkerList from '../components/markers/MarkerList';
import MarkerDetail from '../components/markers/MarkerDetail';
import VideoComparisonPlayer from '../components/video/VideoComparisonPlayer';
import AIAnalysisResult from '../components/video/AIAnalysisResult';
import { MARKER_STATUS_LABELS, MARKER_PRIORITY_LABELS, ISSUE_TYPE_LABELS } from '../utils/constants';
import { formatDate, formatFileSize } from '../utils/helpers';
import toast from 'react-hot-toast';

const MarkersPage: React.FC = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState<MarkerStatus | ''>('');
  const [priorityFilter, setPriorityFilter] = useState<MarkerPriority | ''>('');
  const [issueTypeFilter, setIssueTypeFilter] = useState<IssueType | ''>('');
  
  // 모달 상태
  const [selectedMarker, setSelectedMarker] = useState<Marker | null>(null);
  const [selectedVideo, setSelectedVideo] = useState<Video | null>(null);
  const [selectedAnalysis, setSelectedAnalysis] = useState<Analysis | null>(null);
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [showVideoModal, setShowVideoModal] = useState(false);
  const [showAnalysisModal, setShowAnalysisModal] = useState(false);

  // 페이지네이션
  const [currentPage, setCurrentPage] = useState(0);
  const [pageSize] = useState(10);

  // 필터링된 마커들 조회
  const { 
    markers, 
    loading, 
    error, 
    refetch,
    updateMarker,
    deleteMarker 
  } = useMarkers({
    skip: currentPage * pageSize,
    limit: pageSize,
    search: searchQuery || undefined,
    status: statusFilter || undefined,
    priority: priorityFilter || undefined,
    issue_type: issueTypeFilter || undefined
  });

  // 선택된 마커의 비디오들
  const {
    videos,
    loading: videosLoading
  } = useVideos(selectedMarker?.id || null);

  // 선택된 비디오의 분석들
  const {
    analyses,
    loading: analysesLoading,
    startAnalysis
  } = useAnalyses(selectedVideo?.id || null);

  // 마커 클릭 핸들러
  const handleMarkerClick = (marker: Marker) => {
    setSelectedMarker(marker);
    setShowDetailModal(true);
  };

  // 마커 수정 핸들러
  const handleMarkerEdit = async (markerId: number, updates: any) => {
    try {
      const updatedMarker = await updateMarker(markerId, updates);
      if (updatedMarker) {
        toast.success('마커 정보가 수정되었습니다.');
        if (selectedMarker?.id === markerId) {
          setSelectedMarker(updatedMarker);
        }
      }
    } catch (error) {
      console.error('마커 수정 오류:', error);
      toast.error('마커 수정 중 오류가 발생했습니다.');
    }
  };

  // 마커 삭제 핸들러
  const handleMarkerDelete = async (markerId: number) => {
    if (!window.confirm('이 마커를 삭제하시겠습니까?')) return;
    
    try {
      const success = await deleteMarker(markerId);
      if (success) {
        toast.success('마커가 삭제되었습니다.');
        setShowDetailModal(false);
        setSelectedMarker(null);
      }
    } catch (error) {
      console.error('마커 삭제 오류:', error);
      toast.error('마커 삭제 중 오류가 발생했습니다.');
    }
  };

  // 비디오 클릭 핸들러 (분석 포함)
  const handleVideoClick = (video: Video) => {
    setSelectedVideo(video);
    setShowVideoModal(true);
  };

  // AI 분석 시작 핸들러
  const handleStartAnalysis = async (videoId: number) => {
    try {
      const newAnalysis = await startAnalysis();
      if (newAnalysis) {
        toast.success('AI 분석이 시작되었습니다. 진행 상황을 확인하세요.');
        // 분석 모달 열기
        setSelectedAnalysis(newAnalysis);
        setShowAnalysisModal(true);
      }
    } catch (error) {
      console.error('분석 시작 오류:', error);
      toast.error('AI 분석 시작 중 오류가 발생했습니다.');
    }
  };

  // 분석 결과 클릭 핸들러
  const handleAnalysisClick = (analysis: Analysis) => {
    setSelectedAnalysis(analysis);
    setShowAnalysisModal(true);
  };

  // 검색 초기화
  const handleSearchReset = () => {
    setSearchQuery('');
    setStatusFilter('');
    setPriorityFilter('');
    setIssueTypeFilter('');
    setCurrentPage(0);
  };

  // 페이지 변경 핸들러
  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  useEffect(() => {
    // 필터가 변경되면 첫 페이지로 이동
    setCurrentPage(0);
  }, [searchQuery, statusFilter, priorityFilter, issueTypeFilter]);

  if (loading && markers.length === 0) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <LoadingSpinner size="lg" text="마커 데이터를 불러오는 중..." />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="bg-white rounded-lg shadow-sm p-6">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">🤖 AI 분석 마커 관리</h1>
            <p className="text-gray-600">도로 균열을 AI로 분석하고 유지보수 작업을 관리합니다</p>
          </div>
          <div className="flex items-center space-x-3">
            <button
              onClick={() => refetch()}
              disabled={loading}
              className="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg transition-colors flex items-center space-x-2"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              <span>새로고침</span>
            </button>
          </div>
        </div>
      </div>

      {/* 검색 및 필터 */}
      <div className="bg-white rounded-lg shadow-sm p-6">
        <h2 className="text-lg font-semibold text-gray-900 mb-4">검색 및 필터</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-4">
          {/* 검색 */}
          <div className="lg:col-span-2">
            <label className="block text-sm font-medium text-gray-700 mb-1">검색</label>
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="마커 제목, 도로명, 담당자명..."
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            />
          </div>
          
          {/* 상태 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">상태</label>
            <select
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value as MarkerStatus | '')}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            >
              <option value="">전체</option>
              {Object.entries(MARKER_STATUS_LABELS).map(([key, label]) => (
                <option key={key} value={key}>{label}</option>
              ))}
            </select>
          </div>
          
          {/* 우선순위 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">우선순위</label>
            <select
              value={priorityFilter}
              onChange={(e) => setPriorityFilter(e.target.value as MarkerPriority | '')}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            >
              <option value="">전체</option>
              {Object.entries(MARKER_PRIORITY_LABELS).map(([key, label]) => (
                <option key={key} value={key}>{label}</option>
              ))}
            </select>
          </div>
          
          {/* 이슈 유형 필터 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">이슈 유형</label>
            <select
              value={issueTypeFilter}
              onChange={(e) => setIssueTypeFilter(e.target.value as IssueType | '')}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
            >
              <option value="">전체</option>
              {Object.entries(ISSUE_TYPE_LABELS).map(([key, label]) => (
                <option key={key} value={key}>{label}</option>
              ))}
            </select>
          </div>
        </div>

        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-600">
            {loading ? '검색 중...' : `총 ${markers.length}개의 마커`}
          </div>
          <button
            onClick={handleSearchReset}
            className="text-sm text-primary-600 hover:text-primary-700"
          >
            필터 초기화
          </button>
        </div>
      </div>

      {/* 마커 목록 */}
      <div className="bg-white rounded-lg shadow-sm">
        <div className="p-6 border-b border-gray-200">
          <h2 className="text-lg font-semibold text-gray-900">마커 목록</h2>
        </div>
        
        {error ? (
          <div className="p-6 text-center text-red-600">
            <p className="mb-4">마커 데이터를 불러오는 중 오류가 발생했습니다.</p>
            <p className="text-sm mb-4">{error}</p>
            <button
              onClick={() => refetch()}
              className="bg-red-100 hover:bg-red-200 text-red-800 px-4 py-2 rounded-lg transition-colors"
            >
              다시 시도
            </button>
          </div>
        ) : (
          <div className="p-6">
            <MarkerList 
              markers={markers}
              onMarkerClick={handleMarkerClick}
              loading={loading}
            />
            
            {/* 페이지네이션 */}
            {markers.length > 0 && (
              <div className="flex justify-center items-center mt-6 space-x-2">
                <button
                  onClick={() => handlePageChange(Math.max(0, currentPage - 1))}
                  disabled={currentPage === 0}
                  className="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-50"
                >
                  이전
                </button>
                
                <span className="px-4 py-2 text-sm text-gray-600">
                  페이지 {currentPage + 1}
                </span>
                
                <button
                  onClick={() => handlePageChange(currentPage + 1)}
                  disabled={markers.length < pageSize}
                  className="px-3 py-2 border border-gray-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-50"
                >
                  다음
                </button>
              </div>
            )}
          </div>
        )}
      </div>

      {/* 마커 상세 모달 */}
      <Modal
        isOpen={showDetailModal}
        onClose={() => {
          setShowDetailModal(false);
          setSelectedMarker(null);
        }}
        title={selectedMarker ? `${selectedMarker.title}` : '마커 상세 정보'}
        size="xl"
      >
        {selectedMarker && (
          <div className="space-y-6">
            {/* 기본 정보 */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <MarkerDetail
                  marker={selectedMarker}
                  onEdit={(updates) => handleMarkerEdit(selectedMarker.id, updates)}
                  onDelete={() => handleMarkerDelete(selectedMarker.id)}
                />
              </div>
              
              {/* 상세 통계 */}
              <div className="space-y-4">
                <h3 className="text-lg font-semibold text-gray-900">📊 상세 통계</h3>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-blue-50 rounded-lg p-4 text-center">
                    <div className="text-2xl font-bold text-blue-600">{selectedMarker.video_count}</div>
                    <div className="text-sm text-blue-800">업로드된 비디오</div>
                  </div>
                  <div className="bg-green-50 rounded-lg p-4 text-center">
                    <div className="text-2xl font-bold text-green-600">{selectedMarker.analysis_count}</div>
                    <div className="text-sm text-green-800">AI 분석 완료</div>
                  </div>
                </div>
              </div>
            </div>

            {/* 비디오 및 분석 목록 */}
            <div>
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-semibold text-gray-900">🎥 업로드된 비디오 및 AI 분석</h3>
                <span className="text-sm text-gray-500">{videos.length}개</span>
              </div>
              
              {videosLoading ? (
                <div className="text-center py-8">
                  <LoadingSpinner text="비디오 목록 로딩 중..." />
                </div>
              ) : videos.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                  <div className="text-4xl mb-2">🎥</div>
                  <p>업로드된 비디오가 없습니다</p>
                </div>
              ) : (
                <div className="space-y-4">
                  {videos.map((video) => (
                    <div
                      key={video.id}
                      className="border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow"
                    >
                      <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-4">
                          <div className="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center">
                            <span className="text-2xl">🎥</span>
                          </div>
                          <div className="flex-1 min-w-0">
                            <h4 className="font-medium text-gray-900 truncate">
                              {video.original_filename}
                            </h4>
                            <div className="text-sm text-gray-500 space-y-1">
                              <div>크기: {formatFileSize(video.file_size)} | 업로드: {video.uploaded_by}</div>
                              <div>날짜: {formatDate(video.created_at)}</div>
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex items-center space-x-2">
                          <button
                            onClick={() => handleVideoClick(video)}
                            className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded-lg transition-colors text-sm"
                          >
                            📹 영상 보기
                          </button>
                          
                          {video.has_analysis ? (
                            <span className="inline-flex items-center text-xs text-green-600 bg-green-100 px-2 py-1 rounded">
                              🤖 분석 완료
                            </span>
                          ) : (
                            <button
                              onClick={() => handleStartAnalysis(video.id)}
                              className="bg-purple-500 hover:bg-purple-600 text-white px-3 py-2 rounded-lg transition-colors text-sm"
                            >
                              🚀 AI 분석
                            </button>
                          )}
                        </div>
                      </div>
                      
                      {/* 해당 비디오의 분석 목록 표시 */}
                      {video.has_analysis && (
                        <div className="mt-3 pt-3 border-t border-gray-100">
                          <div className="text-sm text-gray-600 mb-2">AI 분석 결과:</div>
                          <button
                            onClick={() => {
                              // 해당 비디오의 최신 분석 찾기
                              const latestAnalysis = analyses.find(a => a.video_id === video.id);
                              if (latestAnalysis) {
                                handleAnalysisClick(latestAnalysis);
                              }
                            }}
                            className="text-purple-600 hover:text-purple-700 text-sm underline"
                          >
                            📊 분석 결과 보기
                          </button>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        )}
      </Modal>

      {/* 비디오 재생 및 분석 모달 */}
      <Modal
        isOpen={showVideoModal}
        onClose={() => {
          setShowVideoModal(false);
          setSelectedVideo(null);
        }}
        title={selectedVideo ? `${selectedVideo.original_filename}` : '비디오 재생'}
        size="xl"
      >
        {selectedVideo && (
          <div className="space-y-6">
            {/* 분석이 있으면 비교 플레이어, 없으면 일반 플레이어 */}
            {selectedVideo.has_analysis ? (
              <div>
                <h3 className="text-lg font-semibold text-gray-900 mb-4">🎬 원본 vs AI 분석 결과</h3>
                {analyses.length > 0 ? (
                  <VideoComparisonPlayer analysis={analyses[0]} />
                ) : (
                  <div className="text-center py-8">
                    <LoadingSpinner text="분석 데이터 로딩 중..." />
                  </div>
                )}
              </div>
            ) : (
              <div className="space-y-4">
                <div className="bg-black rounded-lg overflow-hidden">
                  <video
                    controls
                    className="w-full h-64"
                  >
                    <source src={`/api/videos/${selectedVideo.id}/stream`} type="video/mp4" />
                    브라우저에서 비디오를 지원하지 않습니다.
                  </video>
                </div>
                
                <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                  <h4 className="font-medium text-yellow-900 mb-2">🤖 AI 분석 대기 중</h4>
                  <p className="text-yellow-700 text-sm mb-3">
                    이 영상은 아직 AI 분석이 완료되지 않았습니다. 분석을 시작하시겠습니까?
                  </p>
                  <button
                    onClick={() => handleStartAnalysis(selectedVideo.id)}
                    className="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg transition-colors text-sm"
                  >
                    🚀 AI 분석 시작
                  </button>
                </div>
              </div>
            )}
          </div>
        )}
      </Modal>

      {/* AI 분석 결과 모달 */}
      <Modal
        isOpen={showAnalysisModal}
        onClose={() => {
          setShowAnalysisModal(false);
          setSelectedAnalysis(null);
        }}
        title="🤖 AI 분석 결과"
        size="xl"
      >
        {selectedAnalysis && (
          <AIAnalysisResult
            analysis={selectedAnalysis}
            onStartAnalysis={() => selectedVideo && handleStartAnalysis(selectedVideo.id)}
            canStartAnalysis={selectedAnalysis.status === 'failed'}
          />
        )}
      </Modal>
    </div>
  );
};

export default MarkersPage;
```

---

### 57. SettingsPage.tsx

- **경로:** `frontend/src/pages/SettingsPage.tsx`
- **크기:** 719 characters
- **타입:** .tsx

```tsx
// frontend/src/pages/SettingsPage.tsx
import React from 'react';

const SettingsPage: React.FC = () => {
  return (
    <div className="space-y-6">
      <div className="bg-white rounded-lg shadow-sm p-6">
        <h1 className="text-2xl font-bold text-gray-900 mb-2">시스템 설정</h1>
        <p className="text-gray-600">시스템 설정 및 사용자 권한을 관리합니다</p>
      </div>
      
      <div className="bg-white rounded-lg shadow-sm p-6">
        <div className="text-center text-gray-500">
          <div className="text-4xl mb-4">⚙️</div>
          <p className="text-lg font-medium">설정 페이지</p>
          <p className="text-sm">시스템 설정과 관리 기능이 여기에 표시됩니다</p>
        </div>
      </div>
    </div>
  );
};

export default SettingsPage;
```

---

### 58. DashboardPage.tsx

- **경로:** `frontend/src/pages/DashboardPage.tsx`
- **크기:** 15,055 characters
- **타입:** .tsx

```tsx
// frontend/src/pages/DashboardPage.tsx (동영상 업로드 지원)
import React, { useEffect, useState } from 'react';
import { dashboardService } from '../services/dashboardService';
import { markerService } from '../services/markerService';
import { videoService } from '../services/videoService';
import { DashboardStats, Activity, RegionStat } from '../types/dashboard';
import { Marker, MarkerCreate } from '../types/marker';
import LoadingSpinner from '../components/common/LoadingSpinner';
import StatCard from '../components/dashboard/StatCard';
import ActivityList from '../components/dashboard/ActivityList';
import NaverMap from '../components/map/NaverMap';
import MarkerAddPopup from '../components/map/MarkerAddPopup';
import { formatNumber } from '../utils/helpers';
import toast from 'react-hot-toast';

const DashboardPage: React.FC = () => {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [activities, setActivities] = useState<Activity[]>([]);
  const [regions, setRegions] = useState<RegionStat[]>([]);
  const [markers, setMarkers] = useState<Marker[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedMarker, setSelectedMarker] = useState<Marker | null>(null);
  
  // 마커 추가 팝업 상태
  const [showMarkerAddPopup, setShowMarkerAddPopup] = useState(false);
  const [newMarkerPosition, setNewMarkerPosition] = useState<{lat: number, lng: number} | null>(null);
  const [creatingMarker, setCreatingMarker] = useState(false);

  // 데이터 새로고침 함수
  const refreshData = async () => {
    try {
      const [statsData, activitiesData, regionsData, markersData] = await Promise.all([
        dashboardService.getStats(),
        dashboardService.getRecentActivities(10),
        dashboardService.getRegionStats(),
        markerService.getMarkers({ limit: 50 })
      ]);
      
      setStats(statsData);
      setActivities(activitiesData);
      setRegions(regionsData);
      setMarkers(markersData);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : '데이터를 불러오는 중 오류가 발생했습니다.';
      setError(errorMessage);
      toast.error(errorMessage);
    }
  };

  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        setLoading(true);
        setError(null);
        await refreshData();
      } catch (err) {
        // 오류는 refreshData에서 처리됨
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardData();
  }, []);

  // 마커 클릭 핸들러
  const handleMarkerClick = (marker: Marker) => {
    setSelectedMarker(marker);
    toast.success(`마커 선택: ${marker.title}`);
  };

  // 지도 클릭 핸들러 (일반 클릭)
  const handleMapClick = (lat: number, lng: number) => {
    console.log('지도 클릭:', lat, lng);
    if (selectedMarker) {
      setSelectedMarker(null);
    }
  };

  // 지도 우클릭 핸들러 (마커 추가)
  const handleMapRightClick = (lat: number, lng: number) => {
    console.log('지도 우클릭 - 마커 추가:', lat, lng);
    setNewMarkerPosition({ lat, lng });
    setShowMarkerAddPopup(true);
    toast('우클릭한 위치에 새 마커를 추가합니다.', {
      icon: '📍',
      duration: 2000
    });
  };

  // 마커 생성 핸들러 (동영상 업로드 포함)
  const handleCreateMarker = async (markerData: MarkerCreate, videoFile?: File) => {
    try {
      setCreatingMarker(true);
      
      console.log('새 마커 생성:', markerData);
      console.log('첨부된 비디오:', videoFile?.name);
      
      // 1. 마커 생성
      const newMarker = await markerService.createMarker(markerData);
      console.log('마커 생성 완료:', newMarker);
      
      // 2. 동영상이 있으면 업로드
      if (videoFile) {
        try {
          toast.loading('동영상 업로드 중...', { duration: 1000 });
          
          const videoUpload = await videoService.uploadVideo(newMarker.id, {
            file: videoFile,
            description: `${markerData.title} 관련 영상`,
            uploaded_by: markerData.created_by
          });
          
          console.log('비디오 업로드 완료:', videoUpload);
          toast.success(`동영상 업로드 완료: ${videoUpload.original_filename}`);
          
          // 마커 정보 업데이트 (비디오 수 반영)
          newMarker.video_count = 1;
          
        } catch (videoError) {
          console.error('비디오 업로드 오류:', videoError);
          toast.error('마커는 생성되었지만 동영상 업로드에 실패했습니다.');
        }
      }
      
      // 3. 로컬 상태 업데이트
      setMarkers(prev => [newMarker, ...prev]);
      
      // 4. 통계 데이터 새로고침
      await refreshData();
      
      const successMessage = videoFile 
        ? `새 마커와 동영상이 업로드되었습니다: ${newMarker.title}`
        : `새 마커가 생성되었습니다: ${newMarker.title}`;
      
      toast.success(successMessage);
      
      // 5. 생성된 마커 선택
      setSelectedMarker(newMarker);
      
    } catch (error) {
      console.error('마커 생성 오류:', error);
      const errorMessage = error instanceof Error ? error.message : '마커 생성 중 오류가 발생했습니다.';
      toast.error(errorMessage);
      throw error;
    } finally {
      setCreatingMarker(false);
    }
  };

  // 마커 추가 팝업 닫기
  const handleCloseMarkerAddPopup = () => {
    setShowMarkerAddPopup(false);
    setNewMarkerPosition(null);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <LoadingSpinner size="lg" text="대시보드 데이터를 불러오는 중..." />
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-6">
        <div className="flex items-center space-x-2">
          <svg className="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span className="text-red-700 font-medium">오류 발생</span>
        </div>
        <p className="text-red-600 mt-2">{error}</p>
        <button 
          onClick={() => window.location.reload()} 
          className="mt-4 bg-red-100 hover:bg-red-200 text-red-800 px-4 py-2 rounded-lg transition-colors"
        >
          다시 시도
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Page Header */}
      <div className="bg-white rounded-lg shadow-sm p-6">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">대시보드</h1>
            <p className="text-gray-600">전국 도로 유지보수 현황을 한눈에 확인하세요</p>
          </div>
          <div className="text-right">
            <div className="text-sm text-gray-500 mb-2">
              <p>마지막 업데이트: {new Date().toLocaleString('ko-KR')}</p>
              <p>총 {markers.length}개 마커 표시 중</p>
            </div>
            <button
              onClick={() => refreshData()}
              className="bg-primary-500 hover:bg-primary-600 text-white px-4 py-2 rounded-lg transition-colors text-sm flex items-center space-x-2"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              <span>새로고침</span>
            </button>
          </div>
        </div>
      </div>

      {/* Stats Cards */}
      {stats && (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6">
          <StatCard
            title="전체 마커"
            value={formatNumber(stats.total_markers)}
            icon="📍"
            color="blue"
          />
          <StatCard
            title="긴급 이슈"
            value={formatNumber(stats.urgent_issues)}
            icon="🚨"
            color="red"
          />
          <StatCard
            title="주간 완료"
            value={formatNumber(stats.weekly_completed)}
            icon="✅"
            color="green"
          />
          <StatCard
            title="대기 중"
            value={formatNumber(stats.pending_markers)}
            icon="⏳"
            color="yellow"
          />
          <StatCard
            title="활성 마커"
            value={formatNumber(stats.active_markers)}
            icon="👤"
            color="purple"
          />
        </div>
      )}

      {/* Main Content Grid */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Map Section */}
        <div className="lg:col-span-2">
          <div className="bg-white rounded-lg shadow-sm overflow-hidden">
            <div className="bg-gray-50 px-6 py-4 border-b">
              <div className="flex justify-between items-center">
                <h2 className="text-lg font-semibold text-gray-900 flex items-center">
                  🗺️ 전국 현황
                </h2>
                <div className="flex items-center space-x-4 text-sm text-gray-600">
                  <div className="flex items-center space-x-1">
                    <span>📍 {markers.length}개 마커</span>
                  </div>
                  {selectedMarker && (
                    <span className="bg-primary-100 text-primary-800 px-2 py-1 rounded text-xs">
                      선택: {selectedMarker.title}
                    </span>
                  )}
                  <div className="text-xs text-blue-600 bg-blue-50 px-2 py-1 rounded">
                    💡 우클릭으로 마커 추가 (동영상 포함 가능)
                  </div>
                </div>
              </div>
            </div>
            
            <div className="p-6">
              {/* 네이버 지도 */}
              <NaverMap
                markers={markers}
                onMarkerClick={handleMarkerClick}
                onMapClick={handleMapClick}
                onMapRightClick={handleMapRightClick}
                height="500px"
                showControls={true}
                center={{ lat: 37.3595704, lng: 127.105399 }}
                zoom={11}
              />
              
              {/* 선택된 마커 정보 */}
              {selectedMarker && (
                <div className="mt-4 bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <div className="flex justify-between items-start">
                    <div className="flex-1">
                      <h3 className="font-semibold text-blue-900">{selectedMarker.title}</h3>
                      <p className="text-blue-700 text-sm mt-1">{selectedMarker.description}</p>
                      <div className="flex items-center space-x-4 mt-2 text-xs text-blue-600">
                        <span>📍 {selectedMarker.road_name || selectedMarker.address}</span>
                        <span>상태: {selectedMarker.status}</span>
                        <span>우선순위: {selectedMarker.priority}</span>
                        <span>담당자: {selectedMarker.assigned_to || '미배정'}</span>
                      </div>
                      <div className="flex items-center space-x-4 mt-1 text-xs text-blue-500">
                        <span>생성일: {new Date(selectedMarker.created_at).toLocaleDateString('ko-KR')}</span>
                        <span>🎥 비디오: {selectedMarker.video_count}개</span>
                        <span>🤖 분석: {selectedMarker.analysis_count}개</span>
                      </div>
                    </div>
                    <button 
                      onClick={() => setSelectedMarker(null)}
                      className="text-blue-400 hover:text-blue-600 p-1"
                      title="선택 해제"
                    >
                      ✕
                    </button>
                  </div>
                </div>
              )}
              
              {/* Region Stats */}
              {regions.length > 0 && (
                <div className="mt-6">
                  <h3 className="text-sm font-medium text-gray-900 mb-3">지역별 통계</h3>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    {regions.map((region) => (
                      <div key={region.name} className="bg-gray-50 rounded-lg p-3 text-center hover:bg-gray-100 transition-colors cursor-pointer">
                        <div className="text-sm text-gray-600">{region.name}</div>
                        <div className="text-lg font-semibold text-gray-900">{formatNumber(region.count)}</div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Recent Activities */}
        <div className="lg:col-span-1">
          <div className="bg-white rounded-lg shadow-sm overflow-hidden">
            <div className="bg-gray-50 px-6 py-4 border-b">
              <h2 className="text-lg font-semibold text-gray-900 flex items-center">
                🔄 실시간 활동
              </h2>
            </div>
            <ActivityList activities={activities} />
          </div>
        </div>
      </div>

      {/* Quick Actions */}
      <div className="bg-white rounded-lg shadow-sm p-6">
        <h2 className="text-lg font-semibold text-gray-900 mb-4">빠른 작업</h2>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <button 
            onClick={() => {
              const centerPosition = { lat: 37.3595704, lng: 127.105399 };
              handleMapRightClick(centerPosition.lat, centerPosition.lng);
            }}
            className="flex items-center justify-center p-4 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors"
          >
            <div className="text-center">
              <div className="text-2xl mb-2">📍🎥</div>
              <div className="text-sm font-medium text-blue-900">마커 + 동영상 등록</div>
            </div>
          </button>
          <button 
            onClick={() => window.location.href = '/markers'}
            className="flex items-center justify-center p-4 bg-green-50 hover:bg-green-100 rounded-lg transition-colors"
          >
            <div className="text-center">
              <div className="text-2xl mb-2">📊</div>
              <div className="text-sm font-medium text-green-900">마커 관리</div>
            </div>
          </button>
          <button className="flex items-center justify-center p-4 bg-purple-50 hover:bg-purple-100 rounded-lg transition-colors">
            <div className="text-center">
              <div className="text-2xl mb-2">🎥</div>
              <div className="text-sm font-medium text-purple-900">영상 분석</div>
            </div>
          </button>
          <button className="flex items-center justify-center p-4 bg-orange-50 hover:bg-orange-100 rounded-lg transition-colors">
            <div className="text-center">
              <div className="text-2xl mb-2">⚙️</div>
              <div className="text-sm font-medium text-orange-900">시스템 설정</div>
            </div>
          </button>
        </div>
      </div>

      {/* 마커 추가 팝업 (동영상 업로드 포함) */}
      <MarkerAddPopup
        isOpen={showMarkerAddPopup}
        position={newMarkerPosition}
        onSubmit={handleCreateMarker}
        onClose={handleCloseMarkerAddPopup}
        loading={creatingMarker}
      />
    </div>
  );
};

export default DashboardPage;
```

---

### 59. __init__.py

- **경로:** `backend/app/__init__.py`
- **크기:** 0 characters
- **타입:** .py

```python

```

---

### 60. config.py

- **경로:** `backend/app/core/config.py`
- **크기:** 1,274 characters
- **타입:** .py

```python
# backend/app/core/config.py
import os
from typing import List
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql://admin:password@localhost:5432/road_maintenance")
    
    # Security
    SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-here-change-this-in-production")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # CORS
    CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://127.0.0.1:3000"]
    
    # File Upload
    UPLOAD_FOLDER: str = os.getenv("UPLOAD_FOLDER", "./uploads")
    MAX_UPLOAD_SIZE: int = int(os.getenv("MAX_UPLOAD_SIZE", 104857600))  # 100MB
    ALLOWED_VIDEO_EXTENSIONS: List[str] = [".mp4", ".avi", ".mov", ".mkv"]
    
    # AI Model
    AI_MODEL_PATH: str = os.getenv("AI_MODEL_PATH", "./ai_model/best.pt")
    
    # Naver Maps
    NAVER_MAP_CLIENT_ID: str = os.getenv("NAVER_MAP_CLIENT_ID", "")
    NAVER_MAP_CLIENT_SECRET: str = os.getenv("NAVER_MAP_CLIENT_SECRET", "")
    
    # Application
    PROJECT_NAME: str = "도로 유지보수 관리 시스템"
    VERSION: str = "1.0.0"
    DESCRIPTION: str = "YOLO 기반 AI 균열 검출을 활용한 도로 유지보수 관리 시스템"

    class Config:
        env_file = ".env"


settings = Settings()
```

---

### 61. __init__.py

- **경로:** `backend/app/core/__init__.py`
- **크기:** 0 characters
- **타입:** .py

```python

```

---

### 62. database.py

- **경로:** `backend/app/core/database.py`
- **크기:** 699 characters
- **타입:** .py

```python
# backend/app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

# SQLAlchemy 엔진 생성
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_recycle=300,
    echo=False  # 개발 시 True로 변경하면 SQL 쿼리 로그 확인 가능
)

# 세션 팩토리 생성
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base 클래스 생성
Base = declarative_base()


# 의존성 주입을 위한 데이터베이스 세션 함수
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# 데이터베이스 테이블 생성 함수
def create_tables():
    Base.metadata.create_all(bind=engine)
```

---

### 63. __init__.py

- **경로:** `backend/app/utils/__init__.py`
- **크기:** 0 characters
- **타입:** .py

```python

```

---

### 64. video_utils.py

- **경로:** `backend/app/utils/video_utils.py`
- **크기:** 9,642 characters
- **타입:** .py

```python
# backend/app/utils/video_utils.py
import cv2
import subprocess
import os
import tempfile
from pathlib import Path
from typing import Dict, Optional, Tuple
import logging

logger = logging.getLogger(__name__)

class VideoProcessor:
    """웹 호환 비디오 처리 클래스"""
    
    def __init__(self):
        self.web_compatible_codec = 'libx264'
        self.web_compatible_format = 'mp4'
        self.target_fps = 30
        self.max_resolution = (1920, 1080)
    
    def convert_to_web_compatible(self, input_path: str, output_path: str) -> Dict[str, any]:
        """
        비디오를 웹 호환 형식으로 변환
        
        Args:
            input_path: 원본 비디오 경로
            output_path: 변환된 비디오 저장 경로
            
        Returns:
            변환 결과 딕셔너리
        """
        try:
            logger.info(f"🎬 비디오 웹 호환성 변환 시작: {input_path}")
            
            # FFmpeg를 사용한 웹 호환 변환
            cmd = [
                'ffmpeg',
                '-i', input_path,
                '-c:v', 'libx264',          # H.264 비디오 코덱
                '-c:a', 'aac',              # AAC 오디오 코덱
                '-preset', 'fast',          # 빠른 인코딩
                '-crf', '23',               # 품질 설정 (18-28, 낮을수록 고품질)
                '-movflags', '+faststart',  # 웹 스트리밍 최적화
                '-pix_fmt', 'yuv420p',      # 픽셀 형식 (웹 호환)
                '-r', str(self.target_fps), # 프레임율 설정
                '-y',                       # 덮어쓰기 허용
                output_path
            ]
            
            # 해상도 조정 (너무 큰 경우)
            width, height = self._get_video_resolution(input_path)
            if width > self.max_resolution[0] or height > self.max_resolution[1]:
                scale = min(self.max_resolution[0]/width, self.max_resolution[1]/height)
                new_width = int(width * scale)
                new_height = int(height * scale)
                # 2의 배수로 맞춤 (인코딩 호환성)
                new_width = new_width if new_width % 2 == 0 else new_width - 1
                new_height = new_height if new_height % 2 == 0 else new_height - 1
                
                cmd.insert(-2, '-vf')  # output_path 앞에 추가
                cmd.insert(-2, f'scale={new_width}:{new_height}')
            
            logger.info(f"🔧 FFmpeg 명령어: {' '.join(cmd)}")
            
            # FFmpeg 실행
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5분 타임아웃
            )
            
            if result.returncode == 0:
                # 변환 성공
                file_size = os.path.getsize(output_path)
                duration = self._get_video_duration(output_path)
                
                logger.info(f"✅ 웹 호환 변환 완료: {output_path}")
                
                return {
                    "success": True,
                    "output_path": output_path,
                    "file_size": file_size,
                    "duration": duration,
                    "codec": "H.264/AAC",
                    "web_compatible": True
                }
            else:
                logger.error(f"❌ FFmpeg 변환 실패: {result.stderr}")
                return {
                    "success": False,
                    "error": f"FFmpeg 오류: {result.stderr}"
                }
                
        except subprocess.TimeoutExpired:
            logger.error("⏰ 비디오 변환 타임아웃")
            return {"success": False, "error": "변환 시간 초과"}
        except Exception as e:
            logger.error(f"💥 비디오 변환 중 오류: {e}")
            return {"success": False, "error": str(e)}
    
    def process_analysis_video(
        self, 
        original_path: str, 
        analysis_frames: list, 
        output_path: str
    ) -> Dict[str, any]:
        """
        분석 결과가 포함된 웹 호환 비디오 생성
        
        Args:
            original_path: 원본 비디오 경로
            analysis_frames: 분석된 프레임 리스트
            output_path: 출력 비디오 경로
        """
        try:
            logger.info(f"🎯 분석 결과 비디오 생성 시작")
            
            # 원본 비디오 정보 추출
            cap = cv2.VideoCapture(original_path)
            fps = int(cap.get(cv2.CAP_PROP_FPS))
            width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            
            # 해상도 조정 (웹 호환성)
            if width > self.max_resolution[0] or height > self.max_resolution[1]:
                scale = min(self.max_resolution[0]/width, self.max_resolution[1]/height)
                width = int(width * scale)
                height = int(height * scale)
                # 2의 배수로 맞춤
                width = width if width % 2 == 0 else width - 1
                height = height if height % 2 == 0 else height - 1
            
            # 웹 호환 비디오 라이터 설정
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(output_path, fourcc, min(fps, self.target_fps), (width, height))
            
            # 프레임 처리 및 저장
            frame_count = 0
            for frame in analysis_frames:
                if frame is not None:
                    # 해상도 조정
                    if frame.shape[:2] != (height, width):
                        frame = cv2.resize(frame, (width, height))
                    
                    out.write(frame)
                    frame_count += 1
            
            cap.release()
            out.release()
            
            if frame_count > 0:
                # OpenCV로 생성된 파일을 웹 호환 형식으로 재변환
                temp_path = output_path + '_temp.mp4'
                os.rename(output_path, temp_path)
                
                conversion_result = self.convert_to_web_compatible(temp_path, output_path)
                
                # 임시 파일 삭제
                if os.path.exists(temp_path):
                    os.remove(temp_path)
                
                if conversion_result["success"]:
                    logger.info(f"✅ 분석 비디오 생성 완료: {frame_count} 프레임")
                    return {
                        "success": True,
                        "output_path": output_path,
                        "frame_count": frame_count,
                        "web_compatible": True
                    }
                else:
                    return conversion_result
            else:
                logger.error("❌ 분석 비디오에 프레임이 없음")
                return {"success": False, "error": "분석 프레임 없음"}
                
        except Exception as e:
            logger.error(f"💥 분석 비디오 생성 중 오류: {e}")
            return {"success": False, "error": str(e)}
    
    def _get_video_resolution(self, video_path: str) -> Tuple[int, int]:
        """비디오 해상도 추출"""
        try:
            cap = cv2.VideoCapture(video_path)
            width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            cap.release()
            return width, height
        except:
            return 1280, 720  # 기본값
    
    def _get_video_duration(self, video_path: str) -> float:
        """비디오 길이 추출"""
        try:
            cap = cv2.VideoCapture(video_path)
            frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            fps = cap.get(cv2.CAP_PROP_FPS)
            duration = frame_count / fps if fps > 0 else 0
            cap.release()
            return duration
        except:
            return 0.0
    
    def validate_web_compatibility(self, video_path: str) -> Dict[str, any]:
        """비디오 웹 호환성 검사"""
        try:
            # FFprobe를 사용한 상세 정보 추출
            cmd = [
                'ffprobe',
                '-v', 'quiet',
                '-print_format', 'json',
                '-show_format',
                '-show_streams',
                video_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                import json
                info = json.loads(result.stdout)
                
                video_stream = None
                audio_stream = None
                
                for stream in info.get('streams', []):
                    if stream.get('codec_type') == 'video':
                        video_stream = stream
                    elif stream.get('codec_type') == 'audio':
                        audio_stream = stream
                
                # 웹 호환성 체크
                is_compatible = True
                issues = []
                
                if video_stream:
                    video_codec = video_stream.get('codec_name', '')
                    if video_codec not in ['h264', 'x264']:
                        is_compatible = False
                        issues.append(f"비디오 코덱 비호환: {video_codec}")
                
                if audio_stream:
                    audio_codec = audio_stream.get('codec_name', '')
                    if audio_codec not in ['aac', 'mp3']:
                        is_compatible = False
                        issues.append(f"오디오 코덱 비호환: {audio_codec}")
                
                return {
                    "compatible": is_compatible,
                    "issues": issues,
                    "video_codec": video_stream.get('codec_name') if video_stream else None,
                    "audio_codec": audio_stream.get('codec_name') if audio_stream else None,
                    "format": info.get('format', {}).get('format_name', '')
                }
            else:
                return {"compatible": False, "error": "파일 분석 실패"}
                
        except Exception as e:
            return {"compatible": False, "error": str(e)}

# 전역 비디오 프로세서 인스턴스
video_processor = VideoProcessor()
```

---

### 65. file_utils.py

- **경로:** `backend/app/utils/file_utils.py`
- **크기:** 1,453 characters
- **타입:** .py

```python
import os
import cv2
from fastapi import UploadFile
from typing import Dict, Optional
from ..core.config import settings


def validate_video_file(file: UploadFile) -> bool:
    """비디오 파일 유효성 검사"""
    
    if not file.filename:
        return False
    
    # 파일 확장자 체크
    file_extension = os.path.splitext(file.filename)[1].lower()
    if file_extension not in settings.ALLOWED_VIDEO_EXTENSIONS:
        return False
    
    # MIME 타입 체크 (선택적)
    if file.content_type and not file.content_type.startswith('video/'):
        return False
    
    return True


def get_video_metadata(file_path: str) -> Dict[str, Optional[float]]:
    """비디오 파일 메타데이터 추출"""
    
    metadata = {
        "duration": None,
        "width": None,
        "height": None,
        "fps": None
    }
    
    try:
        cap = cv2.VideoCapture(file_path)
        
        if cap.isOpened():
            # 프레임 수와 FPS로 지속시간 계산
            frame_count = cap.get(cv2.CAP_PROP_FRAME_COUNT)
            fps = cap.get(cv2.CAP_PROP_FPS)
            
            if fps > 0:
                metadata["duration"] = frame_count / fps
                metadata["fps"] = fps
            
            # 해상도 정보
            metadata["width"] = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            metadata["height"] = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        
        cap.release()
        
    except Exception as e:
        print(f"비디오 메타데이터 추출 오류: {e}")
    
    return metadata

```

---

### 66. model_loader.py

- **경로:** `backend/app/ai_model/model_loader.py`
- **크기:** 2,249 characters
- **타입:** .py

```python
# backend/ai_model/model_loader.py
import os
import torch
from ultralytics import YOLO
from typing import Optional
import logging

logger = logging.getLogger(__name__)

class ModelLoader:
    """YOLO 모델 로더 및 관리 클래스"""
    
    def __init__(self, model_path: str = "best.pt"):
        self.model_path = model_path
        self.model: Optional[YOLO] = None
        self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
        
    def load_model(self) -> bool:
        """YOLO 모델 로드"""
        try:
            # 모델 파일 존재 확인
            if not os.path.exists(self.model_path):
                logger.error(f"모델 파일을 찾을 수 없습니다: {self.model_path}")
                return False
            
            # YOLO 모델 로드
            self.model = YOLO(self.model_path)
            self.model.to(self.device)
            
            logger.info(f"YOLO 모델 로드 완료: {self.model_path} (Device: {self.device})")
            return True
            
        except Exception as e:
            logger.error(f"모델 로드 실패: {str(e)}")
            return False
    
    def is_loaded(self) -> bool:
        """모델 로드 상태 확인"""
        return self.model is not None
    
    def get_model(self) -> Optional[YOLO]:
        """로드된 모델 반환"""
        if not self.is_loaded():
            if not self.load_model():
                return None
        return self.model
    
    def get_model_info(self) -> dict:
        """모델 정보 반환"""
        if not self.is_loaded():
            return {"loaded": False, "error": "모델이 로드되지 않음"}
        
        return {
            "loaded": True,
            "model_path": self.model_path,
            "device": self.device,
            "model_type": "YOLOv8" if hasattr(self.model, 'model') else "YOLO"
        }

# 전역 모델 인스턴스
_model_loader = None

def get_model_loader() -> ModelLoader:
    """싱글톤 모델 로더 반환"""
    global _model_loader
    if _model_loader is None:
        # 모델 파일 경로 설정
        model_path = os.path.join(os.path.dirname(__file__), "best.pt")
        _model_loader = ModelLoader(model_path)
    return _model_loader

def preload_model():
    """애플리케이션 시작 시 모델 미리 로드"""
    loader = get_model_loader()
    if loader.load_model():
        logger.info("YOLO 모델 사전 로드 완료")
    else:
        logger.warning("YOLO 모델 사전 로드 실패")
```

---

### 67. __init__.py

- **경로:** `backend/app/ai_model/__init__.py`
- **크기:** 1,298 characters
- **타입:** .py

```python
# backend/app/ai_model/__init__.py
"""
도로 균열 검출 AI 모듈

YOLO 기반 균열 검출 및 분석 기능을 제공합니다.
"""

try:
    from .model_loader import ModelLoader, get_model_loader, preload_model
    from .inference import CrackDetector
    
    __all__ = [
        'ModelLoader',
        'get_model_loader', 
        'preload_model',
        'CrackDetector'
    ]
    
    # 모듈 로드 상태
    AI_MODULE_AVAILABLE = True
    
except ImportError as e:
    print(f"AI 모듈 의존성 누락: {e}")
    print("ultralytics, torch, opencv-python 패키지를 설치하세요.")
    
    # 더미 클래스 정의
    class ModelLoader:
        def __init__(self, *args, **kwargs):
            self.loaded = False
        
        def load_model(self):
            return False
        
        def get_model_info(self):
            return {"loaded": False, "error": "AI 패키지 미설치"}
    
    class CrackDetector:
        def analyze_video(self, *args, **kwargs):
            raise Exception("AI 모듈이 설치되지 않았습니다. requirements.txt의 AI 패키지들을 설치하세요.")
    
    def get_model_loader():
        return ModelLoader()
    
    def preload_model():
        print("AI 모듈이 설치되지 않아 모델을 로드할 수 없습니다.")
    
    __all__ = [
        'ModelLoader',
        'get_model_loader', 
        'preload_model',
        'CrackDetector'
    ]
    
    AI_MODULE_AVAILABLE = False

# 버전 정보
__version__ = "1.0.0"
```

---

### 68. inference.py

- **경로:** `backend/app/ai_model/inference.py`
- **크기:** 13,846 characters
- **타입:** .py

```python
# backend/ai_model/inference.py
import cv2
import numpy as np
import os
from typing import Dict, List, Tuple, Any, Optional, Callable
from .model_loader import get_model_loader
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

class CrackDetector:
    """균열 검출 및 분석 클래스"""
    
    def __init__(self):
        self.model_loader = get_model_loader()
        self.confidence_threshold = 0.5
        self.iou_threshold = 0.45
        
    def analyze_video(
        self, 
        video_path: str, 
        output_path: str, 
        progress_callback: Optional[Callable[[float], None]] = None
    ) -> Dict[str, Any]:
        """
        비디오 분석 및 웹 호환 결과 영상 생성
        
        Args:
            video_path: 입력 비디오 경로
            output_path: 출력 비디오 경로
            progress_callback: 진행률 콜백 함수
            
        Returns:
            분석 결과 딕셔너리
        """
        try:
            # 모델 로드 확인
            model = self.model_loader.get_model()
            if model is None:
                raise Exception("YOLO 모델을 로드할 수 없습니다.")
            
            # 비디오 캡처 초기화
            cap = cv2.VideoCapture(video_path)
            if not cap.isOpened():
                raise Exception(f"비디오 파일을 열 수 없습니다: {video_path}")
            
            # 비디오 정보 추출
            fps = int(cap.get(cv2.CAP_PROP_FPS))
            width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            
            # 웹 호환 해상도 조정
            max_width, max_height = 1920, 1080
            if width > max_width or height > max_height:
                scale = min(max_width/width, max_height/height)
                width = int(width * scale)
                height = int(height * scale)
                # 2의 배수로 맞춤
                width = width if width % 2 == 0 else width - 1
                height = height if height % 2 == 0 else height - 1
            
            # 임시 출력 파일 (OpenCV 용)
            temp_output = output_path.replace('.mp4', '_temp.mp4')
            
            # 비디오 라이터 초기화 (임시)
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(temp_output, fourcc, min(fps, 30), (width, height))
            
            # 분석 결과 저장용
            all_detections = []
            processed_frames = []
            crack_statistics = {
                'total_frames': total_frames,
                'frames_with_cracks': 0,
                'total_detections': 0,
                'confidence_scores': []
            }
            
            frame_count = 0
            
            logger.info(f"🎥 비디오 분석 시작: {total_frames} 프레임 ({width}x{height})")
            
            while True:
                ret, frame = cap.read()
                if not ret:
                    break
                
                # 해상도 조정
                if frame.shape[:2] != (height, width):
                    frame = cv2.resize(frame, (width, height))
                
                # YOLO 추론 실행
                results = model(frame, conf=self.confidence_threshold, iou=self.iou_threshold)
                
                # 검출 결과 처리
                frame_detections = []
                annotated_frame = frame.copy()
                
                for result in results:
                    boxes = result.boxes
                    if boxes is not None:
                        for box in boxes:
                            # 바운딩 박스 좌표
                            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                            confidence = box.conf[0].cpu().numpy()
                            class_id = int(box.cls[0].cpu().numpy())
                            
                            # 검출 정보 저장
                            detection = {
                                'frame': frame_count,
                                'bbox': [int(x1), int(y1), int(x2), int(y2)],
                                'confidence': float(confidence),
                                'class_id': class_id,
                                'area': (x2 - x1) * (y2 - y1)
                            }
                            frame_detections.append(detection)
                            
                            # 웹 친화적 바운딩 박스 그리기
                            color = (0, 0, 255)  # 빨간색
                            thickness = max(2, int(min(width, height) / 400))  # 해상도에 비례한 두께
                            
                            # 박스 그리기
                            cv2.rectangle(annotated_frame, (int(x1), int(y1)), (int(x2), int(y2)), color, thickness)
                            
                            # 배경이 있는 텍스트 (가독성 향상)
                            label = f"Crack: {confidence:.2f}"
                            font_scale = max(0.5, min(width, height) / 1600)  # 해상도에 비례한 폰트 크기
                            text_thickness = max(1, thickness // 2)
                            
                            # 텍스트 크기 계산
                            (text_width, text_height), baseline = cv2.getTextSize(
                                label, cv2.FONT_HERSHEY_SIMPLEX, font_scale, text_thickness
                            )
                            
                            # 텍스트 배경
                            cv2.rectangle(
                                annotated_frame, 
                                (int(x1), int(y1) - text_height - baseline - 5),
                                (int(x1) + text_width + 5, int(y1)),
                                color, -1
                            )
                            
                            # 텍스트
                            cv2.putText(
                                annotated_frame, label, 
                                (int(x1) + 2, int(y1) - baseline - 2), 
                                cv2.FONT_HERSHEY_SIMPLEX, font_scale, (255, 255, 255), text_thickness
                            )
                
                # 프레임 저장
                out.write(annotated_frame)
                processed_frames.append(annotated_frame)
                
                # 통계 업데이트
                if frame_detections:
                    crack_statistics['frames_with_cracks'] += 1
                    crack_statistics['total_detections'] += len(frame_detections)
                    crack_statistics['confidence_scores'].extend([d['confidence'] for d in frame_detections])
                    all_detections.extend(frame_detections)
                
                frame_count += 1
                
                # 진행률 콜백 호출
                if progress_callback and frame_count % 10 == 0:
                    progress = (frame_count / total_frames) * 80  # 80%까지 (변환용 20% 남김)
                    progress_callback(progress)
            
            # 리소스 해제
            cap.release()
            out.release()
            
            # 웹 호환 형식으로 변환
            logger.info("🔄 웹 호환 형식으로 변환 중...")
            if progress_callback:
                progress_callback(85)
            
            # FFmpeg를 사용한 웹 호환 변환
            import subprocess
            
            ffmpeg_cmd = [
                'ffmpeg',
                '-i', temp_output,
                '-c:v', 'libx264',
                '-preset', 'fast',
                '-crf', '23',
                '-movflags', '+faststart',
                '-pix_fmt', 'yuv420p',
                '-y',
                output_path
            ]
            
            result = subprocess.run(ffmpeg_cmd, capture_output=True, text=True)
            
            # 임시 파일 삭제
            if os.path.exists(temp_output):
                os.remove(temp_output)
            
            if result.returncode != 0:
                logger.warning(f"FFmpeg 변환 실패, 원본 사용: {result.stderr}")
                # 원본을 최종 결과로 복사
                import shutil
                shutil.move(temp_output, output_path)
            
            if progress_callback:
                progress_callback(100)
            
            # 최종 분석 결과 생성
            analysis_result = self._generate_analysis_result(crack_statistics, all_detections)
            
            logger.info(f"✅ 비디오 분석 완료: {frame_count} 프레임 처리, {analysis_result['total_cracks']}개 균열 검출")
            
            return analysis_result
            
        except Exception as e:
            logger.error(f"💥 비디오 분석 중 오류: {str(e)}")
            raise
    
    def _generate_analysis_result(self, statistics: Dict, detections: List[Dict]) -> Dict[str, Any]:
        """분석 결과 생성"""
        
        total_frames = statistics['total_frames']
        frames_with_cracks = statistics['frames_with_cracks']
        total_detections = statistics['total_detections']
        confidence_scores = statistics['confidence_scores']
        
        # 기본 통계
        crack_ratio = (frames_with_cracks / total_frames) * 100 if total_frames > 0 else 0
        avg_confidence = np.mean(confidence_scores) if confidence_scores else 0
        
        # 균열 세부 정보 생성
        crack_details = []
        if detections:
            # 프레임별로 그룹화하여 균열 정보 생성
            frame_groups = {}
            for detection in detections:
                frame = detection['frame']
                if frame not in frame_groups:
                    frame_groups[frame] = []
                frame_groups[frame].append(detection)
            
            # 주요 균열들 선별 (신뢰도 높은 순)
            sorted_detections = sorted(detections, key=lambda x: x['confidence'], reverse=True)
            
            for i, detection in enumerate(sorted_detections[:10]):  # 상위 10개만
                area_pixels = detection['area']
                # 픽셀을 실제 면적으로 변환 (가정: 1픽셀 = 1mm²)
                area_mm2 = area_pixels
                
                crack_detail = {
                    "crack_id": f"crack_{i+1:03d}",
                    "crack_type": "도로 균열",  # YOLO 클래스에 따라 분류 가능
                    "length": float(np.sqrt(area_mm2)),  # 근사값
                    "width": 2.0,  # 기본값
                    "area": float(area_mm2 / 1000000),  # m² 변환
                    "severity": self._determine_severity(detection['confidence'], area_mm2),
                    "confidence": float(detection['confidence']),
                    "frame": detection['frame'],
                    "bbox": detection['bbox']
                }
                crack_details.append(crack_detail)
        
        # 보수재 용량 산정
        total_crack_area = sum([detail['area'] for detail in crack_details])
        material_estimation = self._estimate_materials(total_crack_area)
        
        # 심각도 분석
        severity_analysis = self._analyze_severity(crack_ratio, avg_confidence, total_crack_area)
        
        return {
            "success": True,
            "total_cracks": total_detections,
            "total_area": total_crack_area,
            "confidence": avg_confidence,
            "crack_ratio": crack_ratio,
            "frames_analyzed": total_frames,
            "frames_with_cracks": frames_with_cracks,
            "crack_details": crack_details,
            "material_estimation": material_estimation,
            "severity_analysis": severity_analysis
        }
    
    def _determine_severity(self, confidence: float, area: float) -> str:
        """균열 심각도 판정"""
        if confidence > 0.8 and area > 10000:  # 높은 신뢰도 + 큰 면적
            return "위험"
        elif confidence > 0.6 and area > 5000:
            return "보통"
        else:
            return "경미"
    
    def _estimate_materials(self, total_area: float) -> Dict[str, Any]:
        """보수재 용량 산정"""
        if total_area == 0:
            return {
                "asphalt_concrete": 0,
                "sealer": 0,
                "primer": 0,
                "mesh": None,
                "total_cost": 0
            }
        
        # 단위당 소요량 (예시값)
        asphalt_per_m2 = 0.1  # 톤/m²
        sealer_per_m2 = 2.0   # 리터/m²
        primer_per_m2 = 0.5   # 리터/m²
        
        # 단위당 비용 (원)
        asphalt_cost = 150000  # 원/톤
        sealer_cost = 5000     # 원/리터
        primer_cost = 8000     # 원/리터
        
        asphalt_amount = total_area * asphalt_per_m2
        sealer_amount = total_area * sealer_per_m2
        primer_amount = total_area * primer_per_m2
        
        total_cost = (asphalt_amount * asphalt_cost + 
                     sealer_amount * sealer_cost + 
                     primer_amount * primer_cost)
        
        return {
            "asphalt_concrete": round(asphalt_amount, 2),
            "sealer": round(sealer_amount, 1),
            "primer": round(primer_amount, 1),
            "mesh": round(total_area, 2) if total_area > 1.0 else None,
            "total_cost": int(total_cost)
        }
    
    def _analyze_severity(self, crack_ratio: float, avg_confidence: float, total_area: float) -> Dict[str, Any]:
        """전체 심각도 분석"""
        
        # 위험도 점수 계산 (0-100)
        ratio_score = min(crack_ratio * 2, 50)  # 최대 50점
        confidence_score = avg_confidence * 30   # 최대 30점
        area_score = min(total_area * 10, 20)    # 최대 20점
        
        risk_score = ratio_score + confidence_score + area_score
        
        # 전체 심각도 판정
        if risk_score >= 70:
            overall_severity = "위험"
            urgent_repairs = True
            repair_time = "즉시 (1일 이내)"
        elif risk_score >= 40:
            overall_severity = "보통"
            urgent_repairs = False
            repair_time = "1주일 이내"
        else:
            overall_severity = "경미"
            urgent_repairs = False
            repair_time = "1개월 이내"
        
        return {
            "overall_severity": overall_severity,
            "risk_score": round(risk_score, 1),
            "urgent_repairs_needed": urgent_repairs,
            "estimated_repair_time": repair_time,
            "crack_coverage": f"{crack_ratio:.1f}%"
        }
```

---

### 69. analysis.py

- **경로:** `backend/app/models/analysis.py`
- **크기:** 1,690 characters
- **타입:** .py

```python
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey, Float, JSON
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum
from ..core.database import Base


class AnalysisStatus(str, enum.Enum):
    PENDING = "pending"      # 분석 대기
    PROCESSING = "processing" # 분석 중
    COMPLETED = "completed"   # 분석 완료
    FAILED = "failed"        # 분석 실패


class Analysis(Base):
    __tablename__ = "analyses"

    id = Column(Integer, primary_key=True, index=True)
    
    # 관계 설정
    marker_id = Column(Integer, ForeignKey("markers.id"), nullable=False)
    video_id = Column(Integer, ForeignKey("videos.id"), nullable=False)
    
    # 분석 상태
    status = Column(String(20), default=AnalysisStatus.PENDING)
    progress = Column(Float, default=0.0)  # 0-100 진행률
    
    # AI 분석 결과
    total_cracks_detected = Column(Integer, default=0)
    total_crack_area = Column(Float, default=0.0)  # m² 단위
    confidence_score = Column(Float, default=0.0)  # 0-1 신뢰도
    
    # 상세 분석 데이터 (JSON)
    crack_details = Column(JSON)  # 개별 균열 정보들
    material_estimation = Column(JSON)  # 보수재 용량 산정
    severity_analysis = Column(JSON)  # 심각도 분석
    
    # 결과 파일
    result_video_path = Column(String(500))  # AI 분석 결과 비디오
    result_data_path = Column(String(500))   # 분석 데이터 파일
    
    # 오류 정보
    error_message = Column(Text)
    
    # 시간 정보
    started_at = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # 관계 설정
    marker = relationship("Marker", back_populates="analyses")
    video = relationship("Video", back_populates="analyses")

```

---

### 70. video.py

- **경로:** `backend/app/models/video.py`
- **크기:** 1,098 characters
- **타입:** .py

```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, BigInteger, Float
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base


class Video(Base):
    __tablename__ = "videos"

    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String(255), nullable=False)
    original_filename = Column(String(255), nullable=False)
    file_path = Column(String(500), nullable=False)
    file_size = Column(BigInteger)  # 바이트 단위
    
    # 비디오 메타데이터
    duration = Column(Float)  # 초 단위
    width = Column(Integer)
    height = Column(Integer)
    fps = Column(Float)
    
    # 마커와의 관계
    marker_id = Column(Integer, ForeignKey("markers.id"), nullable=False)
    
    # 업로드 정보
    uploaded_by = Column(String(100))
    description = Column(String(500))
    
    # 시간 정보
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # 관계 설정
    marker = relationship("Marker", back_populates="videos")
    analyses = relationship("Analysis", back_populates="video", cascade="all, delete-orphan")

```

---

### 71. marker.py

- **경로:** `backend/app/models/marker.py`
- **크기:** 1,738 characters
- **타입:** .py

```python
# backend/app/models/marker.py
from sqlalchemy import Column, Integer, String, Text, DateTime, Float, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum
from ..core.database import Base


class MarkerStatus(str, enum.Enum):
    PENDING = "pending"      # 처리 대기
    PROGRESS = "progress"    # 작업 중  
    COMPLETED = "completed"  # 완료


class MarkerPriority(str, enum.Enum):
    URGENT = "urgent"        # 긴급
    HIGH = "high"           # 높음
    NORMAL = "normal"       # 보통


class IssueType(str, enum.Enum):
    POTHOLE = "pothole"           # 방사 균열
    CRACK = "crack"               # 도로 균열
    SIGN_DAMAGE = "sign_damage"   # 표지판 손상


class Marker(Base):
    __tablename__ = "markers"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(255), nullable=False, index=True)
    description = Column(Text)
    
    # 위치 정보
    latitude = Column(Float, nullable=False)
    longitude = Column(Float, nullable=False)
    address = Column(String(500))
    road_name = Column(String(255))
    
    # 분류 정보
    issue_type = Column(Enum(IssueType), default=IssueType.CRACK)
    status = Column(Enum(MarkerStatus), default=MarkerStatus.PENDING)
    priority = Column(Enum(MarkerPriority), default=MarkerPriority.NORMAL)
    
    # 담당자 및 등록자
    assigned_to = Column(String(100))
    created_by = Column(String(100))
    
    # 시간 정보
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 관계 설정
    videos = relationship("Video", back_populates="marker", cascade="all, delete-orphan")
    analyses = relationship("Analysis", back_populates="marker", cascade="all, delete-orphan")
```

---

### 72. __init__.py

- **경로:** `backend/app/models/__init__.py`
- **크기:** 335 characters
- **타입:** .py

```python
from .marker import Marker, MarkerStatus, MarkerPriority, IssueType
from .video import Video  
from .analysis import Analysis, AnalysisStatus

# SQLAlchemy Base import
from ..core.database import Base

__all__ = [
    "Base",
    "Marker", "MarkerStatus", "MarkerPriority", "IssueType",
    "Video",
    "Analysis", "AnalysisStatus"
]

```

---

### 73. analysis.py

- **경로:** `backend/app/schemas/analysis.py`
- **크기:** 2,121 characters
- **타입:** .py

```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, Dict, Any, List
from ..models.analysis import AnalysisStatus


class CrackDetail(BaseModel):
    crack_id: str
    crack_type: str  # "횡방향", "종방향", "망상" 등
    length: float    # 미터
    width: float     # 밀리미터
    area: float      # 제곱미터
    severity: str    # "위험", "보통", "경미"
    confidence: float # 0-1


class MaterialEstimation(BaseModel):
    asphalt_concrete: float  # 톤
    sealer: float           # 리터
    primer: float           # 리터
    mesh: Optional[float] = None  # 제곱미터
    total_cost: float       # 원


class SeverityAnalysis(BaseModel):
    overall_severity: str   # "위험", "보통", "경미"
    risk_score: float      # 0-100
    urgent_repairs_needed: bool
    estimated_repair_time: str  # "1일", "3일" 등


class AnalysisBase(BaseModel):
    marker_id: int
    video_id: int


class AnalysisCreate(AnalysisBase):
    pass


class AnalysisUpdate(BaseModel):
    status: Optional[AnalysisStatus] = None
    progress: Optional[float] = Field(None, ge=0, le=100)
    total_cracks_detected: Optional[int] = None
    total_crack_area: Optional[float] = None
    confidence_score: Optional[float] = Field(None, ge=0, le=1)
    crack_details: Optional[List[CrackDetail]] = None
    material_estimation: Optional[MaterialEstimation] = None
    severity_analysis: Optional[SeverityAnalysis] = None
    result_video_path: Optional[str] = None
    result_data_path: Optional[str] = None
    error_message: Optional[str] = None


class AnalysisResponse(AnalysisBase):
    id: int
    status: AnalysisStatus
    progress: float
    total_cracks_detected: int
    total_crack_area: float
    confidence_score: float
    crack_details: Optional[List[Dict[str, Any]]] = None
    material_estimation: Optional[Dict[str, Any]] = None
    severity_analysis: Optional[Dict[str, Any]] = None
    result_video_path: Optional[str] = None
    error_message: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime

    class Config:
        from_attributes = True

```

---

### 74. video.py

- **경로:** `backend/app/schemas/video.py`
- **크기:** 788 characters
- **타입:** .py

```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional


class VideoBase(BaseModel):
    original_filename: str
    description: Optional[str] = None


class VideoCreate(VideoBase):
    filename: str
    file_path: str
    file_size: int
    marker_id: int
    uploaded_by: str
    duration: Optional[float] = None
    width: Optional[int] = None
    height: Optional[int] = None
    fps: Optional[float] = None


class VideoResponse(VideoBase):
    id: int
    filename: str
    file_size: int
    duration: Optional[float]
    width: Optional[int]
    height: Optional[int]
    fps: Optional[float]
    marker_id: int
    uploaded_by: str
    created_at: datetime
    has_analysis: bool = False

    class Config:
        from_attributes = True

```

---

### 75. marker.py

- **경로:** `backend/app/schemas/marker.py`
- **크기:** 2,031 characters
- **타입:** .py

```python
# backend/app/schemas/marker.py
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, List
from ..models.marker import MarkerStatus, MarkerPriority, IssueType


class MarkerBase(BaseModel):
    title: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    latitude: float = Field(..., ge=-90, le=90)
    longitude: float = Field(..., ge=-180, le=180)
    address: Optional[str] = None
    road_name: Optional[str] = None
    issue_type: IssueType = IssueType.CRACK
    priority: MarkerPriority = MarkerPriority.NORMAL
    assigned_to: Optional[str] = None


class MarkerCreate(MarkerBase):
    created_by: str


class MarkerUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=255)
    description: Optional[str] = None
    status: Optional[MarkerStatus] = None
    priority: Optional[MarkerPriority] = None
    assigned_to: Optional[str] = None


class MarkerResponse(MarkerBase):
    id: int
    status: MarkerStatus
    created_by: str
    created_at: datetime
    updated_at: Optional[datetime]
    video_count: int = 0
    analysis_count: int = 0

    class Config:
        from_attributes = True


# backend/app/schemas/video.py
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional


class VideoBase(BaseModel):
    original_filename: str
    description: Optional[str] = None


class VideoCreate(VideoBase):
    filename: str
    file_path: str
    file_size: int
    marker_id: int
    uploaded_by: str
    duration: Optional[float] = None
    width: Optional[int] = None
    height: Optional[int] = None
    fps: Optional[float] = None


class VideoResponse(VideoBase):
    id: int
    filename: str
    file_size: int
    duration: Optional[float]
    width: Optional[int]
    height: Optional[int]
    fps: Optional[float]
    marker_id: int
    uploaded_by: str
    created_at: datetime
    has_analysis: bool = False

    class Config:
        from_attributes = True


```

---

### 76. __init__.py

- **경로:** `backend/app/schemas/__init__.py`
- **크기:** 345 characters
- **타입:** .py

```python
from .marker import MarkerCreate, MarkerUpdate, MarkerResponse
from .video import VideoCreate, VideoResponse
from .analysis import AnalysisCreate, AnalysisUpdate, AnalysisResponse

__all__ = [
    "MarkerCreate", "MarkerUpdate", "MarkerResponse",
    "VideoCreate", "VideoResponse", 
    "AnalysisCreate", "AnalysisUpdate", "AnalysisResponse"
]

```

---

### 77. tsconfig.json

- **경로:** `frontend/tsconfig.json`
- **크기:** 627 characters
- **타입:** .json

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "es6"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": [
    "src",
    "src/types/naver-maps.d.ts"
  ]
}
```

---

### 78. sample_data.sql

- **경로:** `database/sample_data.sql`
- **크기:** 0 characters
- **타입:** .sql

```sql

```

---

### 79. init.sql

- **경로:** `database/init.sql`
- **크기:** 0 characters
- **타입:** .sql

```sql

```

---

### 80. README.md

- **경로:** `README.md`
- **크기:** 865 characters
- **타입:** .md

```markdown
# 도로 유지보수 관리 시스템

YOLO 기반 AI 균열 검출을 활용한 도로 유지보수 관리 시스템

## 기술 스택
- Frontend: React + TypeScript + Tailwind CSS
- Backend: FastAPI + SQLAlchemy + PostgreSQL
- AI: YOLO (Ultralytics)
- Map: Naver Maps API

## 시작하기

### 1. 환경변수 설정
```bash
# Backend 환경변수
cp backend/.env.example backend/.env
# Frontend 환경변수  
cp frontend/.env.local.example frontend/.env.local
```

### 2. Docker로 실행
```bash
docker-compose up --build
```

### 3. 개별 실행
```bash
# Backend
cd backend
source venv/bin/activate
uvicorn app.main:app --reload

# Frontend
cd frontend
npm start
```

## API 문서
- Backend API: http://localhost:8000/docs
- Frontend: http://localhost:3000

## 디렉토리 구조
```
road-maintenance-system/
├── frontend/          # React 프론트엔드
├── backend/           # FastAPI 백엔드
├── database/          # DB 초기화 스크립트
├── ai_model/          # AI 모델 파일
└── uploads/           # 업로드된 파일들
```

```

---

### 81. README.md

- **경로:** `frontend/README.md`
- **크기:** 2,103 characters
- **타입:** .md

```markdown
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

```

---

